# 概念

Java编译器将Java源程序编译成与平台无关的字节码文件(class文件)，由Java虚拟机（JVM）对字节码文件解释执行。不同的操作系统下实现java程序的跨平台。

- JVM（Java Virtual Machine）：Java虚拟机

- JRE（Java Runtime Environment）：Java运行环境，包含了JVM和Java的核心类库（Java API）

- JDK（Java Development Kit）: 称为Java开发工具，包含了JRE和开发工具

| 目录名称 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| bin      | 该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。 |
| conf     | 该路径下存放了JDK的相关配置文件。                            |
| include  | 该路径下存放了一些平台特定的头文件。                         |
| jmods    | 该路径下存放了JDK的各种模块。                                |
| legal    | 该路径下存放了JDK各模块的授权文档。                          |
| lib      | 该路径下存放了JDK工具的一些补充JAR包。                       |

# 注释

注释是对代码的解释和说明文字，可提高程序的可读性。Java中的注释分为三种：

- 单行注释。

- 多行注释。
- 文档注释。

```java
//单行注释

/*
这是多行注释文字
这是多行注释文字
这是多行注释文字
*/

/**
*文档注释
*/
```

# 关键字

关键字是指被java语言赋予了特殊含义的单词。

关键字的特点：

- 关键字的字母全部小写，常用的代码编辑器对关键字都有高亮显示，比如现在我们能看到的public、class、static等。

​       ![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1591781912346-3c29035a-9531-4cee-af74-a2190de10c5c.png)

- - private 表示私有，只有自己类能访问
  - default表示没有修饰符修饰，只有同一个包的类能访问

- - protected表示可以被同一个包的类以及其他包中的子类访问
  - public表示可以被该项目的所有包中的所有类访问

# 常量

常量：在程序运行过程中，其值不可以发生改变的量。

Java中的常量分类：

1. 字符串常量：用双引号括起来的多个字符（可以包含0个、一个或多个）。
2. 整数常量：整数。
3. 小数常量：小数。
4. 字符常量：用单引号括起来的一个字符。
5. 布尔常量：布尔值，表示真假，只有两个值true和false
6. 空常量：一个特殊的值，空值，值为null

除空常量外，其他常量均可使用输出语句直接输出。

# 数据类型

**计算机存储单元**

计算机是用来存储数据的，无论是内存还是硬盘，计算机存储设备的最小信息单元叫“位（bit）”，我们又称之为“比特位”，通常用小写的字母”b”表示。而计算机中最基本的存储单元叫“字节（byte）”。

通常用大写字母”B”表示，字节是由连续的8个位组成。

除了字节外还有一些常用的存储单位，其换算单位如下：

1B（字节） = 8bit

1KB = 1024B

1MB = 1024KB

1GB = 1024MB

1TB = 1024GB

## **Java中的数据类型**

Java是一个强类型语言，必须明确数据类型。在Java中的数据类型包括基本数据类型和引用数据类型两种。

Java中的基本数据类型：

| 数据类型 | 关键字       | 内存占用 | 取值范围                                                     |
| -------- | ------------ | -------- | ------------------------------------------------------------ |
| 整数类型 | byte         | 1        | -128~127                                                     |
|          | short        | 2        | -32768~32767                                                 |
|          | int(默认)    | 4        | -2的31次方到2的31次方-1                                      |
|          | long         | 8        | -2的63次方到2的63次方-1                                      |
| 浮点类型 | float        | 4        | 负数：-3.402823E+38到-1.401298E-45                                                             正数：   1.401298E-45到3.402823E+38 |
|          | double(默认) | 8        | 负数：-1.797693E+308到-4.9000000E-324                                              正数：4.9000000E-324   到1.797693E+308 |
| 字符类型 | char         | 2        | 0-65535                                                      |
| 布尔类型 | boolean      | 1        | true，false                                                  |

说明：

​	e+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。

​	在java中整数默认是int类型，浮点数默认是double类型。

## **变量**

变量：在程序运行过程中，其值可以发生改变的量。

从本质上讲，变量是内存中的一小块区域，其值可以在一定范围内变化。

变量的定义格式：

- 数据类型 变量名 = 初始化值; 

- 数据类型 变量名;

  变量名 = 初始化值;

还可以在同一行定义多个同一种数据类型的变量，中间使用逗号隔开。但不建议使用这种方式，降低程序的可读性。

变量的使用：通过变量名访问即可。

**使用变量时的注意事项**

- 在同一对花括号中，变量名不能重复。
- 变量在使用之前，必须初始化（赋值）。
- 定义long类型的变量时，需要在整数的后面加L（大小写均可，建议大写）。因为整数默认是int类型，整数太大可能超出int范围。
- 定义float类型的变量时，需要在小数的后面加F（大小写均可，建议大写）。因为浮点数的默认类型是double， double的取值范围是大于float的，类型不兼容。

## **标识符**

标识符是用户编程时使用的名字，用于给类、方法、变量、常量等命名。

Java中标识符的组成规则：

- 由字母、数字、下划线“_”、美元符号“$”组成，第一个字符不能是数字。
- 不能使用java中的关键字作为标识符。	
- 标识符对大小写敏感（区分大小写）。

Java中标识符的命名约定：

- 小驼峰式命名：变量名、方法名
  - 首字母小写，从第二个单词开始每个单词的首字母大写。

- 大驼峰式命名：类名
  - 每个单词的首字母都大写。

​	另外，标识符的命名最好可以做到见名知意

## **类型转换**

在Java中，一些数据类型之间是可以相互转换的。分为两种情况：自动类型转换和强制类型转换。

自动类型转换：

​	把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量。这种转换方式是自动的，直接书写即可。如：

```java
double num = 10; // 将int类型的10直接赋值给double类型
System.out.println(num); // 输出10.0
```

强制类型转换：

​	把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量。

​	强制类型转换格式：目标数据类型 变量名 = (目标数据类型)值或者变量;

​	如：

```java
double num1 = 5.5;
int num2 = (int) num1; // 将double类型的num1强制转换为int类型
System.out.println(num2); // 输出5（小数位直接舍弃）
```

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1609770479591-15c4f64a-e1bf-4ec6-bf1c-e0758d0a5afb.png)

说明：

1. char类型的数据转换为int类型是按照码表中对应的int值进行计算的。比如在ASCII码表中，'a'对应97。

1. 整数默认是int类型，byte、short和char类型数据参与运算均会自动转换为int类型。
2. boolean类型不能与其他基本数据类型相互转换。

- 

# 运算符



**运算符和表达式**

运算符：对常量或者变量进行操作的符号

表达式：用运算符把常量或者变量连接起来符合java语法的式子就可以称为表达式。

不同运算符连接的表达式体现的是不同类型的表达式。

## **算术运算符**

| 符号 | 作用 | 说明                         |
| ---- | ---- | ---------------------------- |
| +    | 加   | 参看小学一年级               |
| -    | 减   | 参看小学一年级               |
| *    | 乘   | 参看小学二年级，与“×”相同    |
| /    | 除   | 参看小学二年级，与“÷”相同    |
| %    | 取余 | 获取的是两个数据做除法的余数 |

注意：

/和%的区别：两个数据做除法，/取结果的商，%取结果的余数。

整数操作只能得到整数，要想得到小数，必须有浮点数参与运算。

**字符的“+”操作**

char类型参与算术运算，使用的是计算机底层对应的十进制数值。需要我们记住三个字符对应的数值：

'a'  --  97		a-z是连续的，所以'b'对应的数值是98，'c'是99，依次递加

'A'  --  65		A-Z是连续的，所以'B'对应的数值是66，'C'是67，依次递加

'0'  --  48		0-9是连续的，所以'1'对应的数值是49，'2'是50，依次递加

```java
// 可以通过使用字符与整数做算术运算，得出字符对应的数值是多少
char ch1 = 'a';
System.out.println(ch1 + 1); // 输出98，97 + 1 = 98
```

算术表达式中包含不同的基本数据类型的值的时候，整个算术表达式的类型会自动进行提升。

```java
byte b1 = 10;
byte b2 = 20;
// byte b3 = b1 + b2; // 该行报错，因为byte类型参与算术运算会自动提示为int，int赋值给byte可能损失精度
int i3 = b1 + b2; // 应该使用int接收
byte b3 = (byte) (b1 + b2); // 或者将结果强制转换为byte类型
-------------------------------
int num1 = 10;
double num2 = 20.0;
double num3 = num1 + num2; // 使用double接收，因为num1会自动提升为double类型
```

tips：正是由于上述原因，所以在程序开发中我们很少使用byte或者short类型定义整数。也很少会使用char类型定义字符，而使用字符串类型，更不会使用char类型做算术运算。

 **字符串的“+”操作**

当“+”操作中出现字符串时，这个”+”是字符串连接符，而不是算术运算。

```java
System.out.println("itheima"+ 666); // 输出：itheima666
```

在”+”操作中，如果出现了字符串，就是连接运算符，否则就是算术运算。

**赋值运算符**

赋值运算符的作用是将一个表达式的值赋给左边，左边必须是可修改的，不能是常量。

| 符号 | 作用       | 说明                  |
| ---- | ---------- | --------------------- |
| =    | 赋值       | a=10，将10赋值给变量a |
| +=   | 加后赋值   | a+=b，将a+b的值给a    |
| -=   | 减后赋值   | a-=b，将a-b的值给a    |
| *=   | 乘后赋值   | a*=b，将a×b的值给a    |
| /=   | 除后赋值   | a/=b，将a÷b的商给a    |
| %=   | 取余后赋值 | a%=b，将a÷b的余数给a  |

注意：

扩展的赋值运算符隐含了强制类型转换。

```java
short s = 10;
s = s + 10; // 此行代码报出，因为运算中s提升为int类型，运算结果int赋值给short可能损失精度

s += 10; // 此行代码没有问题，隐含了强制类型转换，相当于 s = (short) (s + 10);
```

## **自增自减运算符**

| 符号 | 作用 | 说明        |
| ---- | ---- | ----------- |
| ++   | 自增 | 变量的值加1 |
| --   | 自减 | 变量的值减1 |

注意事项：

​	++和-- 既可以放在变量的后边，也可以放在变量的前边。

​	单独使用的时候， ++和-- 无论是放在变量的前边还是后边，结果是一样的。

​	参与操作的时候，如果放在变量的后边，先拿变量参与操作，后拿变量做++或者--。

​	参与操作的时候，如果放在变量的前边，先拿变量做++或者--，后拿变量参与操作。

## **关系运算符**

关系运算符有6种关系，分别为小于、小于等于、大于、等于、大于等于、不等于。

| 符号 | 说明                                                    |
| ---- | ------------------------------------------------------- |
| ==   | a==b，判断a和b的值是否相等，成立为true，不成立为false   |
| !=   | a!=b，判断a和b的值是否不相等，成立为true，不成立为false |
| >    | a>b，判断a是否大于b，成立为true，不成立为false          |
| >=   | a>=b，判断a是否大于等于b，成立为true，不成立为false     |
| <    | a<b，判断a是否小于b，成立为true，不成立为false          |
| <=   | a<=b，判断a是否小于等于b，成立为true，不成立为false     |

注意事项：

​	关系运算符的结果都是boolean类型，要么是true，要么是false。

​	千万不要把“”误写成“=”，""是判断是否相等的关系，"="是赋值。

## **逻辑运算符**

逻辑运算符把各个运算的关系表达式连接起来组成一个复杂的逻辑表达式，以判断程序中的表达式是否成立，判断的结果是 true 或 false。

| 符号 | 作用     | 说明                                         |
| ---- | -------- | -------------------------------------------- |
| &    | 逻辑与   | a&b，a和b都是true，结果为true，否则为false   |
| \|   | 逻辑或   | a\|b，a和b都是false，结果为false，否则为true |
| ^    | 逻辑异或 | a^b，a和b结果不同为true，相同为false         |
| !    | 逻辑非   | !a，结果和a的结果正好相反                    |



| 符号 | 作用   | 说明                         |
| ---- | ------ | ---------------------------- |
| &&   | 短路与 | 作用和&相同，但是有短路效果  |
| \|\| | 短路或 | 作用和\|相同，但是有短路效果 |

- 逻辑与&，无论左边真假，右边都要执行。

- 短路与&&，如果左边为真，右边执行；如果左边为假，右边不执行。

- 逻辑或|，无论左边真假，右边都要执行。

- 短路或||，如果左边为假，右边执行；如果左边为真，右边不执行。

## **三元运算符**

三元运算符语法格式：

```java
关系表达式 ? 表达式1 : 表达式2;
```

解释：问号前面的位置是判断的条件，判断结果为boolean型，为true时调用表达式1，为false时调用表达式2。

# 数据输入

我们可以通过 Scanner 类来获取用户的输入。使用步骤如下：

1、导包。Scanner 类在java.util包下，所以需要将该类导入。导包的语句需要定义在类的上面。

```java
import java.util.Scanner;
```

2、创建Scanner对象。

```java
Scanner sc = new Scanner(System.in);// 创建Scanner对象，sc表示变量名，其他均不可变
```

3、接收数据

```java
int i = sc.nextInt(); // 表示将键盘录入的值作为int数返回。
```

示例：

```java
import java.util.Scanner;
public class ScannerDemo {
	public static void main(String[] args) {
		//创建对象
		Scanner sc = new Scanner(System.in);
		//接收数据
		int x = sc.nextInt();
		//输出数据
		System.out.println("x:" + x);
	}
}
```

# 流程控制语句

在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候要通过控制语句的执行顺序来实现我们想要的功能。

## 顺序结构

顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。

顺序结构执行流程图：

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1609771050169-685b89b6-c7fa-47a7-a43e-3573c0bc5dc1.png)

## if语句

**格式一：**

```java
if (关系表达式) {
    语句体;	
}
```

执行流程：

①首先计算关系表达式的值

②如果关系表达式的值为true就执行语句体

③如果关系表达式的值为false就不执行语句体

④继续执行后面的语句内容



![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1609771072835-cd67aabd-89ae-4d2d-9c38-96cbc7e601e4.png)



**格式二：**

```java
if (关系表达式) {
    语句体1;	
} else {
    语句体2;	
}
```

执行流程：

①首先计算关系表达式的值

②如果关系表达式的值为true就执行语句体1

③如果关系表达式的值为false就执行语句体2

④继续执行后面的语句内容

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1609771114533-0b3d0953-4b91-48c5-8eb6-45b36073b3e9.png)

**格式三**

```java
if (关系表达式1) {
    语句体1;	
} else if (关系表达式2) {
    语句体2;	
} 
…
else {
    语句体n+1;
}
```

执行流程：

①首先计算关系表达式1的值

②如果值为true就执行语句体1；如果值为false就计算关系表达式2的值

③如果值为true就执行语句体2；如果值为false就计算关系表达式3的值

④…

⑤如果没有任何关系表达式为true，就执行语句体n+1。

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1609771145140-1405f26d-5008-48eb-ae40-9ab95ffd0a08.png)

# instanceof关键字

- - **用于判断该运算符前面引用类型变量指向的对象是否是后面类、其子类、接口实现类创建的对象。如果是则返回true，否则返回false**
  - **其使用格式如下：引用类型变量 instanceof （类、抽象类或接口）**

- - 向下转型的之前判断一下当前的实例是否为某个类的对象，避免出现ClassCastException异常
  - **对象 instanceof 类→返回 boolean类型**

# Object

- - 无任何继承结构，一切的类都是Object子类
  - class Ball{} 与class Ball extends Object{}效果相同，object可以接收所有的子类实例

- - object可以接收所有引用数据类型（数组、类、接口）
  - 获取对象信息:**public String toString()**，object默认的toString()方法返回的只是实例化对象的地址，有需要可以自己覆写

- - **对象打印可以调用toString()**，对象是引用类型，而toString()方法是将对象转为字符串，返回其地址，即printfln(对象)，返回的是对象的地址，而重写后便可返回自己想要的内容
  - object类对象的比较方法：**public boolean equals(Object obj)，比较hashcode，相同返回true，可以根据需求重写，不同返回false，传统的"=="用于对象实现的是两个堆内存地址的比较，用于基本数据类型则是值的比较**

- - 当**toString**拼写错误成为tostring的时候，程序仍可以运行，其认为tostring是子类扩充的新方法，此时可以用''@Override''明确定义在子类覆写的方法中，表明其不为子类独有，而是通过覆写得到
  - ''@Override''利用此注解有两个好处：

- - - 避免错误的方法覆写定义；
    - 是提示用户那些方法是覆写定义的，那些方法是子类新定义的。

- - ''@Deprecated''实现过期的定义操作，程序执行不出现任何问题，只有过期的提示信息
  - ''@SuppressWarnings('''')''压制警告信息，使得警告信息不重复提示

# 缓存处理

- - - 整型、char类型所对应的包装类，在自动装箱时，对于-128~127之间的值会进行缓存处理，其目的是提高效率。
    - 缓存处理的原理为：如果数据在-128~127这个区间，那么在类加载时就已经为该区间的每个数值创建了对象，并将这256个对象存放到一个名为cache的数组中。每当自动装箱过程发生时(或者手动调用valueOf()时)，就会先判断数据是否在该区间，如果在则直接获取数组中对应的包装类对象的引用，如果不在该区间，则会通过new调用包装类的构造方法来创建对象。

# 枚举

- - enum关键字实现枚举类的定义，遵循多例设计模式的原则---构造方法私有化，内部有多个对象常量
  - 使用enum定义的枚举类可以方便的通过values()静态方法获取全部枚举定义内容

- - switch支持枚举，enum相当于继承了Enum这个父类
  - 枚举中可以定义类结构，实现接口，**对象常量必须全部大写**  例如enum Sex{MALE'男',FEMALE'女'；其他语句；}

​             ![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1591781912801-5f556354-bdcb-4002-9785-c05b9b945b3e.png)

# Runtime类

- - Runtime描述的是运行时的概念，每一个JVM进程里面都会包含有一个运行时的实例化对象，该对象运行类型就是Runtime类
  - 唯一一个可以描述JVM进程信息的程序类，Runtime run=Runtime.getRuntime()；

- - java中提供有垃圾收集机制，两种形式：自动垃圾回收、手工回收，Runtime.gc()表示手工回收垃圾的处理



| No   | 方法名称                  | 类型 | 描述                                                         |
| ---- | ------------------------- | ---- | ------------------------------------------------------------ |
| 01   | public long maxMemory()   | 方法 | 获取该JVM进程可以操作的最大内存数量【整体内存的1/4】         |
| 02   | public long totalMemory() | 方法 | 获取该JVM进程中可以使用到的常规最大内存数量【整体内存的1/64】 |
| 03   | public long freeMemory()  | 方法 | 获取空余的内存数量                                           |
| 04   | public void gc()          | 方法 | 调用垃圾收集机制                                             |

# System类

- - public static long currentTimeMillis()：获取当前的日期时间数，实现最简单的耗时统计处理
  - System类中有一个gc方法：public static void gc()，本质上调用了Runtime类中的gc()，手工的gc()方法只有一个，就是在Runtime类中定义的

#  Cleaner类

- - 传统的对象回收是使用Object类中的finallize()方法，但这种方法会由于对对象本身的回收问题或者产生死锁问题，后来被废除了

```java
import java.lang.ref.Cleaner;
class Member implements Runnable{      //线程类
  public Member(){
     System.out.println("对象实例化调用");
  }
@Override
public void run(){
   System.out.println("对象回收");
  }
}
class MemberCleaner implements AutoCloseable{
 private static final Cleaner cleaner=Cleaner.create();  //创建一个回收对象
 private Cleaner.Cleanable cleanable;   //可以被回收的对象
 public MemberCleaner(Member member){   //处理要回收的对象
     this.cleanable=cleaner.register(this,member);   //注册一个可回收对象
}
 @Override
 public void close() throws Exception{   //释放资源
    this.cleanable.clean(); //回收对象 
 }
}
public class TestDemo{
  public static void main(String[] args) throws Exception{
  Member men=new Member();
  System.gc();  //强制性的进行回收 
  try(MemberCleaner mc=new MemberCleaner(mem)){  //进行对象回收的处理
//如果有需求则可以进行其他的处理操作
 }catch(Exception e){}
}
}
```

