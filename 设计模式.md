设计模式的一般定义如下：

> 是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。

# 原则

**概述**

| 设计原则名称 | 定 义                                                        | 使用频率 |
| ------------ | ------------------------------------------------------------ | -------- |
| 单一职责原则 | 一个类只负责一个功能领域中的相应职责                         | ★★★★☆    |
| 开闭原则     | 软件实体应对扩展开放，而对修改关闭（体现接口和抽象）         | ★★★★★    |
| 里氏代换原则 | 所有引用基类对象的地方能够透明地使用其子类的对象（体现多态转换） | ★★★★★    |
| 依赖倒转原则 | 抽象不应该依赖于细节，细节应该依赖于抽象                     | ★★★★★    |
| 接口隔离原则 | 使用多个专门的接口，而不使用单一的总接口                     | ★★☆☆☆    |
| 合成复用原则 | 尽量使用对象组合，而不是继承来达到复用的目的                 | ★★★★☆    |
| 迪米特法则   | 一个软件实体应当尽可能少地与其他实体发生相互作用             | ★★★☆☆    |

## **创建型模式**

- **工厂方法模式**：足球生产商是工厂，足球是产品。增加一种新的足球品牌，对应需要增加一个新的生产商。
  - 工厂方法模式(Factory Method)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式使一个类的实例化延迟到其子类。

- **抽象工厂模式**：同一品牌的足球、球鞋、球服、球袜构成了一个产品族，一个工厂可以生产一族产品，而不只是一种产品。
  - 抽象工厂模式(Abstract Factory): 提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。

- **单例模式**：每个球队的守门员有且仅有一个，可为单例。
  - 单例模式(Singleton): 保证一个类仅有一个实例，并提供一个访问它的全局访问点。

- **建造者模式**：销售人员相当于建造者模式中的指挥者(Director)，向用户返回一个复杂产品(足球装备)，该复杂产品由多个部件组成(球衣、球裤、球袜等)，用户无须关心具体组装过程即可得到一个完整的复杂产品。
  - 建造者模式(Builder): 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

- **原型模式**：无论是足球还是球服，都是批量生产的，先做一个原型（模板），然后照着生产就好了，想要多少就生产多少。
  - 原型模式(Prototype):用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。

## **结构型模式**

- **适配器模式**：翻译充当了外国教练和队员之间的适配器，负责协调教练和队员之间的交流。
  - 适配器模式(Adapter): 将一个类的接口转换成用户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

- **桥接模式**：在足球比赛中，有人踢前锋、有人踢中场、有人踢后卫；有人习惯踢左边、有人习惯踢右边等，是多个变化维度的组合
  - 桥接模式(Bridge): 将抽象部分与实现部分分离，使它们都可以独立地变化。

- **组合模式**：若用一个图来表示欧洲杯全体球员及各国分组情况，一定是个树状图。
  - 组合模式(Composite): 将对象组合成树形结构以表示“部分-整体”的层次结构，它使得客户对单个对象和复合对象的使用具有一致性。

- **装饰模式**：足球服上的广告，增加新的广告，只需对原有球服继续装饰即可。
  - 装饰模式(Decorator): 动态地给一个对象添加一些额外的职责，就扩展功能而言， 它比生成子类的方式更为灵活。

- **外观模式**：新闻发布会充当了记者（客户端）和队员、教练（子系统）之间的外观角色。当然，新闻发布会并不会影响某位记者单独采访某位球员。
  - 外观模式(Facade): 子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加容易使用。

- **享元模式**：同一个国家队的队员，他们都共享着一个伟大的称谓，每个队员身披不同号码的球衣，因此，球衣号码是不能够共享的外部状态。在享元模式中区分了对象的内部状态和外部状态。
  - 享元模式(Flyweight): 运用共享技术有效地支持大量细粒度的对象。

- **代理模式**：经纪人就是球员的代理，球员是目标对象，而经纪人是代理对象，经纪人隔离了球员和“客户端”。
  - 代理模式(Proxy)：为其他对象提供一个代理以控制对这个对象的访问。

## **行为型模式**

- **职责链模式**：足球就是一个请求，而球员就是请求的处理者，足球在球员间不断进行传递，构成了一条传递链。
  - 职责链模式(Chain of Responsibility): 为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求；将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。

- **命令模式**：主教练就是命令的发送者，手势就是命令对象，所有队员都是命令的接收者。不同的命令对象将对应不同的执行动作。
  - 命令模式(Command): 将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。

- **解释器模式**：教练的手势就是一门语言，每个队员都需要在比赛中阅读教练的手势并将其转换成执行指令，按照教练的意图来展开攻守。
  - 解释器模式(Interpreter): 定义语言的文法，并且建立一个解释器来解释该语言中的句子。

- **迭代器模式**：球队是一个包含多个队员的聚合对象，可以提供一个迭代器来遍历其中的队员。
  - 迭代器模式(Iterator): 提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。

- **中介者模式**：裁判经常是足球赛场的主角，当两队队员发生冲突时，他充当了球员之间的中介者（调停者）

  - 中介者模式(Mediator): 用一个中介对象来封装一系列的对象交互；中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

  

# 创建型模式



## 简单工厂模式

> 简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开，它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用。

**1. 主要优点**

简单工厂模式的主要优点如下：

-  工厂类包含必要的判断逻辑，实现了对象创建和使用的分离。
- 对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。
- **通过引入配置文件**，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。

**2. 主要缺点**

简单工厂模式的主要缺点如下：

- 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。
- 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。
- 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。
- 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

**3. 适用场景**

在以下情况下可以考虑使用简单工厂模式：

- 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。

- 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。

![2019060810013__1.png](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/2019060810013__1.png)

**示例**

```java
//抽象图表接口：抽象产品类
interface Chart{
    public void display();
}

//柱状图类：具体产品类
class HistogramChart implements Chart{
    public HistogramChart(){
        System.out.println("创建柱状图！");
    }
    public void display(){
        System.out.println("显示柱状图！");
    }
}

//饼状图类：具体产品类
class PieChart implements Chart{
    public PieChart(){
        System.out.println("创建饼状图！");
    }
    public void display(){
        System.out.println("显示饼状图！");
    }
}

//图表工厂类：工厂类
class ChartFactory{
//静态工厂方法
    public static ChartgetChart(String type){
        Chartchart=null;
        if(type.equalsIgnoreCase("histogram")){
            chart=new HistogramChart();
            System.out.println("初始化设置柱状图！");
        }
        else if(type.equalsIgnoreCase("pie")){
            chart=new PieChart();
            System.out.println("初始化设置饼状图！");
        }
        return chart;
    }
}

// 客户端测试
class Client{
    public static void main(String args[]){
        Chart chart;
        chart=ChartFactory.getChart("histogram");
        chart.display();
    }
}
```

## 工厂方法模式

简单工厂模式缺点：当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码，将违背开闭原则。

> 工厂方法模式：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式是一种类创建型模式。

工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。

**1. 主要优点**

- 在工厂方法模式中，工厂方法用来创建客户所需要的产品，用户只需要关心所需产品对应的工厂，无须关心创建细节。

- 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。

- 在系统中加入新产品时，而只要添加一个具体工厂和具体产品就可以了，可扩展性好，完全符合“开闭原则”。

**2. 主要缺点**

- 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度与开销。

- 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。

**3. 适用场景**

在以下情况下可以考虑使用工厂方法模式：

- 客户端无需知道所需要对象的类。具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。

- 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，从而使得系统更容易扩展。

```java
//日志记录器接口：抽象产品
    interface Logger {
        public void writeLog();
    }

    //数据库日志记录器：具体产品
    class DatabaseLogger implements Logger {
        public void writeLog() {
            System.out.println("数据库日志记录。");
        }
    }

    //文件日志记录器：具体产品
    class FileLogger implements Logger {
        public void writeLog() {
            System.out.println("文件日志记录。");
        }
    }

    //日志记录器工厂接口：抽象工厂
    interface LoggerFactory {
        public Logger createLogger();
    }

    //数据库日志记录器工厂类：具体工厂
    class DatabaseLoggerFactory implements LoggerFactory {
        public Logger createLogger() {
                //连接数据库，代码省略
                //创建数据库日志记录器对象
                Logger logger = new DatabaseLogger();
                //初始化数据库日志记录器，代码省略
                return logger;
        }
    }

    //文件日志记录器工厂类：具体工厂
    class FileLoggerFactory implements LoggerFactory {
        public Logger createLogger() {
                //创建文件日志记录器对象
                Logger logger = new FileLogger();
                //创建文件，代码省略
                return logger;
        }
    }

// 客户端
class Client {
        public static void main(String args[]) {
            LoggerFactory factory;
            Logger logger;
            factory = new FileLoggerFactory(); //可引入配置文件实现
            logger = factory.createLogger();
            logger.writeLog();
        }
    }
```

## 抽象工厂模式

抽象工厂模式为创建一组对象提供了一种解决方案。**与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品**。抽象工厂模式定义如下：

> 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。

![2019060810021_1.png](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/2019060810021_1.png)

在抽象工厂模式结构图中包含如下几个角色：

**● AbstractFactory（抽象工厂）：** 它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。

**● ConcreteFactory（具体工厂）：** 它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。

**● AbstractProduct（抽象产品）：** 它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。

**● ConcreteProduct（具体产品）：** 它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。

在抽象工厂中声明了多个工厂方法，用于创建不同类型的产品，抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下所示：

```java
abstract class AbstractFactory {
    public abstract AbstractProductA createProductA(); //工厂方法一
    public abstract AbstractProductB createProductB(); //工厂方法二
    ……
    }
```

具体工厂实现了抽象工厂，每一个具体的工厂方法可以返回一个特定的产品对象，而同一个具体工厂所创建的产品对象构成了一个产品族。对于每一个具体工厂类，其典型代码如下所示：

```java
class ConcreteFactory1 extends AbstractFactory {
        //工厂方法一
    public AbstractProductA createProductA() {
        return new ConcreteProductA1();
    }
    //工厂方法二
    public AbstractProductB createProductB() {
        return new ConcreteProductB1();
    }
    ……
    }
```

**1. 主要优点**

- 抽象工厂模式隔离了具体类的生成，使得客户无需知道细节。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可改变整个软件系统的行为。

- 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。

- 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。

**2. 主要缺点**

- 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。

**3. 适用场景**

- 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。

- 系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。

- 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。

- 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。

## 单例模式

**懒汉式**

优点：资源懒加载，减小资源消耗；采用双重校验为了提升线程的效率，防止线程阻塞严重，并且采用synchronized和volatile关键字来保证线程安全。

```java
    public class Singleton {
       //通过volatile关键字来确保安全
       private volatile static Singleton singleton;
    
       private Singleton(){}
    
       public static Singleton getInstance(){
           if(singleton == null){
               synchronized (Singleton.class){
                   if(singleton == null){
                       singleton = new Singleton();
                   }
               }
           }
           return singleton;
       }
    }
    
```

**饿汉式**

优点：资源初始化的时候即加载，实现逻辑较简单。

```java
    public class Singleton {
       private  static Singleton singleton = new Singleton();
    
       private Singleton(){}
    
       public static Singleton getInstance(){
           return this.singleton;
       }
    }
    
```

**静态内部类实现**

优点：既可实现延迟加载，又可保证线程安全，不影响系统性能。

```java
    public class Singleton {
       private static class SingletonHolder{
           public static Singleton singleton = new Singleton();
       }
    
       public static Singleton getInstance(){
           return SingletonHolder.singleton;
       }
    }
```

**1.主要优点**

- 单例模式提供了对唯一实例的受控访问。

- 只存在一个对象，因此可以节约系统资源。

- 允许可变数目的实例。基于单例模式我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例单例对象共享过多有损性能的问题。

**2.主要缺点**

- 由于单例模式中没有抽象层，故扩展有困难。

- 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。

- 若实例化的共享对象长时间不被利用，GC会自动销毁并回收资源，下次利用时将重新实例化，导致共享的单例对象状态的丢失。

**3.适用场景**

在以下情况下可以考虑使用单例模式：

- 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。

- 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。

## 原型模式

由原型对象，再通过复制这个原型对象来创建更多同类型的对象。原型模式的定义如下：

> 原型模式：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。



原型模式是一种“另类”的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法来实现。

![2019060910030_2.png](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/2019060910030_2.png)

在原型模式结构图中包含如下几个角色：

●Prototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。

● ConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。

● Client（客户类）：客户通过调用相应的原型类对象的克隆方法得到返回的原型类。

**通用实现方法：在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其返回，并将相关的参数传入新创建的对象中，保证它们的成员属性相同。**

**clone方法：所有Java类继承自java.lang.Object，Object类提供一个clone()方法，可以复制Java对象，实现克隆的Java类必须实现一个标识接口Cloneable。**

为了获取对象的一份拷贝，可以直接利用Object类的clone()方法，具体步骤如下：

1. 在派生类中覆盖基类的clone()方法，并声明为public；

2. 在派生类的clone()方法中，调用super.clone()；

3. 派生类需实现Cloneable接口。

浅克隆：指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。

深克隆：不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。

**1.主要优点**

- 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。

- 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。

- 原型模式提供了简化的创建结构，通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。

- 可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候恢复，可辅助实现撤销操作。

**2.主要缺点**

- 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。

- 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。

**3.适用场景**

- 创建新对象成本较大，新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。

- 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。

- 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。

## 建造者模式

将客户端与包含多个组成部分的复杂对象的创建过程分离，客户端无须知道复杂对象的内部组成部分与装配方式，只需要知道所需建造者的类型即可。不同的具体建造者定义了不同的创建过程，且具体建造者相互独立，增加新的建造者具有较好的扩展性。

建造者模式定义如下：

> 建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。

![](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/2019060910034_2.png)

在建造者模式结构图中包含如下几个角色：

● Builder（抽象建造者）： 构建者的抽象基类（有时会使用接口代替）。其定义了构建Product的抽象步骤，其实体类需要实现这些步骤。其会包含一个用来返回最终产品的方法`Product getProduct()`。

●ConcreteBuilder（具体建造者）：Builder的实现类。

●Product（产品角色）：被构建的复杂对象，包含多个组成部件。

● Director（指挥者）：决定如何构建最终产品的算法. 其会包含一个负责组装的方法`void Construct(Builder builder)`， 在这个方法中通过调用builder的方法，就可以设置builder，等设置完成后，就可以通过builder的 `getProduct()` 方法获得最终的产品。

```java
public class Computer {
    private final String cpu;//必须
    private final String ram;//必须
    private final int usbCount;//可选
    private final String keyboard;//可选
    private final String display;//可选

    private Computer(Builder builder){
        this.cpu=builder.cpu;
        this.ram=builder.ram;
        this.usbCount=builder.usbCount;
        this.keyboard=builder.keyboard;
        this.display=builder.display;
    }
    public static class Builder{
        private String cpu;//必须
        private String ram;//必须
        private int usbCount;//可选
        private String keyboard;//可选
        private String display;//可选

        public Builder(String cup,String ram){
            this.cpu=cup;
            this.ram=ram;
        }

        public Builder setUsbCount(int usbCount) {
            this.usbCount = usbCount;
            return this;
        }
        public Builder setKeyboard(String keyboard) {
            this.keyboard = keyboard;
            return this;
        }
        public Builder setDisplay(String display) {
            this.display = display;
            return this;
        }        
        public Computer build(){
            return new Computer(this);
        }
    }
  //省略getter方法
}

//客户端
Computer computer=new Computer.Builder("因特尔","三星")
                .setDisplay("三星24寸")
                .setKeyboard("罗技")
                .setUsbCount(2)
                .build();
```

**1.主要优点**

- 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。

- 每一个具体建造者都相对独立，而与其他的具体建造者无关，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合“开闭原则”

- 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。

**2.主要缺点**

- 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，因此其使用范围受到一定的限制。

- 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。

**3.适用场景**

- 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。
- 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。
- 对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。
- 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。

# 结构型模式

## 适配器模式

适配器模式可以将一个类的接口和另一个类的接口匹配起来，而无须修改原来的适配者接口和抽象目标类接口。适配器模式定义如下：

> 适配器模式：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。

![img](https://pic1.zhimg.com/80/v2-b989b7e4e70e29f68f147ee5f9d52afc_720w.jpg)

从上图可见，适配器模式只有3个角色

- Target（目标抽象类）：是一个接口，它是我们客户端使用的目标接口

- Adaptee（适配者类）：我们想要使用的接口与`Target`不兼容的类，它可以是一个接口，也可以是一个类。

- Adapter（适配器类）：适配器类，此模式的核心。它需要实现目标接口`Target`，而且必须要引用`Adaptee`，因为我们要在此类中包装`Adaptee`的功能

```java
// 原接口
public interface LogFactory {
    void debug(String tag,String message);
}

// 第三方接口及实现
public interface NbLogger {
    void d(int priority, String message, Object ... obj);
}

public class NbLoggerImp implements NbLogger {
    @Override
    public void d(int priority, String message, Object... obj) {
        System.out.println(String.format("牛逼logger记录:%s",message));
    }
}

// 适配器类
public class LogAdapter implements LogFactory {
    private NbLogger nbLogger;

    public LogAdapter(NbLogger nbLogger) {
        this.nbLogger = nbLogger;
    }

    @Override
    public void debug(String tag, String message) {
        Objects.requireNonNull(nbLogger);
        nbLogger.d(1, message);
    }
}


// 客户端使用
public class AdapterClient {
    public void recordLog() {
        LogFactory logFactory = new LogAdapter(new NbLoggerImp());
        logFactory.debug("Test", "我将使用牛逼logger打印log");
    }
}
```

适配器模式将现有接口转化为客户类所期望的接口，实现了对现有类的复用，在软件开发中得以广泛应用，在Spring等开源框架、JDBC等中也使用了适配器模式。

对象适配器：通过持有相关对象引用进行适配

类适配器：通过实现为适配者类的子类来适配方法，也可置换相关方法

**1. 主要优点**

-  **将目标类和适配者类解耦**，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。

- **增加了类的透明性和复用性**，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。

- **灵活性和扩展性都非常好**，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。

**2. 主要缺点**

与类适配器模式相比，**要在适配器中置换适配者类的某些方法比较麻烦**。

**3. 适用场景**

- 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。

- 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。

## 桥接模式

若软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。

桥接模式用一种巧妙的方式处理多层继承存在的问题，用抽象关联取代了传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系，使得系统更加灵活，并易于扩展，同时有效控制了系统中类的个数。桥接定义如下：

> 桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。

桥接模式的结构与其名称一样，存在一条连接两个继承等级结构的桥，桥接模式结构如图10-3所示：

![2019060910042_1.png](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/2019060910042_1.png)

在桥接模式结构图中包含如下几个角色：

● Abstraction（抽象类）：用于定义抽象类的接口，一般是抽象类，其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象。

● RefinedAbstraction（扩充抽象类）：扩充由Abstraction定义的接口，通常情况下它是具体类，实现了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法。

● Implementor（实现类接口）：定义实现类的接口，Implementor接口仅提供基本操作。

● ConcreteImplementor（具体实现类）：具体实现Implementor接口，在不同的ConcreteImplementor中提供基本操作的不同实现，在程序运行时，ConcreteImplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。

```java
interface Implementor {
        public void operationImpl();
    }
    

abstract class Abstraction {
        protected Implementor impl; //定义实现类接口对象
        public void setImpl(Implementor impl) {
            this.impl=impl;
        }
        public abstract void operation();  //声明抽象业务方法
    }


class RefinedAbstraction extends Abstraction {
        public void operation() {
            //业务代码
            impl.operationImpl();  //调用实现类的方法
            //业务代码
        }
    }
```

桥接模式为多维度变化的系统提供了一套完整的解决方案，并且降低了系统的复杂度。

**1.主要优点**

- 分离抽象接口及其实现部分。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。

- 桥接模式可以取代多层继承方案，多层继承方案违背了“单一职责原则”，复用性较差，且类的个数非常多。

- 桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”。

**2.主要缺点**

- 桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。

- 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。

**3.适用场景**

- 如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系。

- 系统需要对抽象化角色和实现化角色进行动态耦合。

- 一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展。

- 对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。

## 组合模式

对于树形结构，当容器对象的某一个方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员对象并调用执行，牵一而动百，使用了递归调用的机制来对整个结构进行处理。

组合模式定义如下：

> 组合模式：组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式，它是一种对象结构型模式。

在组合模式中引入了抽象构件类Component，它是所有容器类和叶子类的公共父类，客户端针对Component进行编程。

![2019060910046_1.png](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/2019060910046_1.png)

在组合模式结构图中包含如下几个角色：

**● Component（抽象构件）：** 它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。

**● Leaf（叶子构件）：** 它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。

**● Composite（容器构件）：** 它在组合结构中表示容器节点对象，容器节点包含所有子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。

```java
abstract class Component {
        public abstract void add(Component c); //增加成员
        public abstract void remove(Component c); //删除成员
        public abstract Component getChild(int i); //获取成员
        public abstract void operation();  //业务方法
    }


class Leaf extends Component {
        public void add(Component c) {
            //异常处理或错误提示
        }
        public void remove(Component c) {
            //异常处理或错误提示
        }
        public Component getChild(int i) {
            //异常处理或错误提示
            return null;
        }
        public void operation() {
            //叶子构件具体业务方法的实现
        }
    }


class Composite extends Component {
        private ArrayList<Component> list = new ArrayList<Component>();
        public void add(Component c) {
            list.add(c);
        }
        public void remove(Component c) {
            list.remove(c);
        }
        public Component getChild(int i) {
            return (Component)list.get(i);
        }
        public void operation() {
            //容器构件具体业务方法的实现
            //递归调用成员构件的业务方法
            for(Object obj:list) {
                ((Component)obj).operation();
            }
        }   
    }

```

**1. 主要优点**

- 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，方便对整个层次结构进行控制。

- 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。

- 在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合“开闭原则”。

- 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。

**2. 主要缺点**

类型难以进行限制，相关节点都来自于相同的抽象层，在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂。

**3. 适用场景**

- 在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。

- 在一个使用面向对象语言开发的系统中需要处理一个树形结构。

- 在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。

## 装饰模式

装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。

装饰模式定义如下：

> 装饰模式：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/196558-20161022031352513-383819617.png)

在装饰模式结构图中包含如下几个角色：

● Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。

● ConcreteComponent（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。

● Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。

● ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。

```java
// Component
public interface ICoffee {
    void makeCoffee();
}

// ConcreteComponent
public class OriginalCoffee implements ICoffee {
    @Override
    public void makeCoffee() {
        System.out.print("原味咖啡 ");
    }
}

// Decorator
public abstract class CoffeeDecorator implements ICoffee {
    private  ICoffee coffee;
    public CoffeeDecorator(ICoffee coffee){
        this.coffee=coffee;
    }

    @Override
    public void makeCoffee() {
        coffee.makeCoffee();
    }
}

// ConcreteDecorator
public class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(ICoffee coffee) {
        super(coffee);
    }
    @Override
    public void makeCoffee() {
        super.makeCoffee();
        addMilk();
    }
    private void addMilk(){
           System.out.print("加奶 ");
     }    
}
```

装饰模式降低了耦合度，可以动态操作对象的职责，并使得需要装饰的具体构件类和具体装饰类可以独立变化，以便增加新的具体构件类和具体装饰类。装饰模式应用体现在Java IO中的输入流和输出流的设计等。

**1.主要优点**

- 对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。

- 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为。

- 可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。

- 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。

**2.主要缺点**

- 使用装饰模式进行系统设计时将产生很多小对象，在一定程序上影响程序的性能。

- 装饰模式提供了一种比继承更加灵活机动的解决方案，调试较为繁琐。

**3.适用场景**

- 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。

- 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。

## 外观模式

外观模式中，一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔开，使得客户类只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道。

外观模式定义如下：

> 外观模式：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

![2019061510054_3.png](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/2019061510054_3.png)

外观模式包含如下两个角色：

**Facade（外观角色）：**在外观角色中可以知道相关的子系统的功能和责任，将客户端请求委派到相应的子系统去，传递给相应的子系统对象处理。

**SubSystem（子系统角色）：** 在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能。

```java
class SubSystemA
   {
       public void MethodA()
       {
           //业务实现代码
       }
   }
   class SubSystemB
   {
       public void MethodB()
       {
           //业务实现代码
        }
   }
   class SubSystemC
   {
       public void MethodC()
       {
           //业务实现代码
       }
   }

class Facade
   {
       private SubSystemA obj1 = new SubSystemA();
       private SubSystemB obj2 = new SubSystemB();
       private SubSystemC obj3 = new SubSystemC();
       public void Method()
       {
           obj1.MethodA();
           obj2.MethodB();
           obj3.MethodC();
       }
   }
```

通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，使子系统与客户端的耦合度降低，且客户端调用非常方便。

**1.主要优点**

- 对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。

- 它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。

- 一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。

**2.主要缺点**

- 不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。

- 如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。

**3.适用场景**

- 当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。

- 客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。

- 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。

## 享元模式

- **内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享**

- **外部状态是随环境改变而改变的、不可以共享的状态**

享元模式定义如下：

> 享元模式：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。

![img](https://pic3.zhimg.com/80/v2-1066edd398fd6c354303163116029d4a_720w.jpg)

在享元模式结构图中包含如下几个角色：

- Flyweight：享元接口，定义所有对象共享的操作

- ConcreteFlyweight：具体的要被共享的对象，其一般是一个不可变类，内部只保存需要共享的内部状态，它可能不止一个。

- FlyweightFactory：负责给客户端提供共享对象

其实经典的享元模式还有一个`UnshareConcreteFlyweight`的角色，它也实现`Flyweight`接口。它的作用是当你不需要共享对象时，但是又需要以统一接口处理此对象，就可以添加这个角色。

```java
public interface Chess {
    //绘制棋子
    void draw(int x,int y);
}

//黑棋
public class BlackChess implements Chess {
    //内部状态，共享
    private final Color color = Color.BLACK;

    private final String sharp = "圆形";

    public Color getColor() {
        return color;
    }

    @Override
    public void draw(int x, int y) {
        System.out.println(String.format("%s%s棋子置于（%d，%d）处", sharp, color.getAlias(), x, y));
    }
}

//白棋
public class WhiteChess implements Chess {
    //内部状态，共享
    private final Color color = Color.WHITE;

    private final String sharp = "圆形";

    public Color getColor() {
        return color;
    }

    @Override
    public void draw(int x, int y) {
        System.out.println(String.format("%s%s棋子置于（%d，%d）处", sharp, color.getAlias(), x, y));
    }
}

public class ChessFactory {
    private static final Map<Color, Chess> chessMap = new HashMap<>();

    public static Chess getChess(Color color) {
        Chess chess = chessMap.get(color);
        if (chess == null) {
            chess = color == Color.WHITE ? new WhiteChess() : new BlackChess();
            chessMap.put(color, chess);
        }
        return chess;
    }
}

public class FlyweightClient {

    public void playChess() {
        //下黑子
        Chess backChess1 = ChessFactory.getChess(Color.BLACK);
        backChess1.draw(2, 5);

        //下白子
        Chess whiteChess = ChessFactory.getChess(Color.WHITE);
        whiteChess.draw(3, 5);

        //下黑子
        Chess backChess2 = ChessFactory.getChess(Color.BLACK);
        backChess2.draw(2, 6);

        System.out.println(String.format("backChess1:%d | backChess2:%d | whiteChess:%d",
                backChess1.hashCode(), backChess2.hashCode(), whiteChess.hashCode()));
    }
}
```

通过共享技术实现相同或相似的细粒度对象的复用，从而节约了内存空间，提高了系统性能。

**1.主要优点**

- 可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。

- 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。

**2.主要缺点**

- 享元模式使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。

- 为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长。

**3.适用场景**

在以下情况下可以考虑使用享元模式：

- 一个系统有大量相同或者相似的对象，造成内存的大量耗费。

- 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。

- 在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。

## 代理模式

代理模式是一种对象结构型模式。在代理模式中引入了一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。

> 代理模式：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。

![2019061510062_2.png](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/2019061510062_2.png)

由图可知，代理模式包含如下三个角色：

- **Subject（抽象主题角色）：** 它声明了真实主题和代理主题的共同接口，通常需要针对抽象主题角色进行编程。

- **Proxy（代理主题角色）：** 包含了对真实主题的引用，从而可以在任何时候操作真实主题对象。

- **RealSubject（真实主题角色）：** 它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。

```java
abstract class Subject
    {
        public abstract void Request();
    }

class RealSubject extends Subject
    {
        @Override
        public void Request()
        {
            //业务方法具体实现代码
        }
    }

class Proxy extends Subject
    {
        private RealSubject realSubject = new RealSubject(); //维持一个对真实主题对象的引用
        public void PreRequest()
        {
            …...
        }
        @Override
        public  void Request()
        {
            PreRequest();
            realSubject.Request(); //调用真实主题对象的方法
             PostRequest();
        }
        public void PostRequest()
        {
            ……
        }
    }
```

在实际开发中，代理类实现比上述代码要复杂，根据其目的和实现方式可分为很多种类，其中常用的几种代理模式如下：

* **远程代理(Remote Proxy)**： 为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中。

- **虚拟代理(Virtual Proxy)：** 若需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。

-  **保护代理(Protect Proxy)**：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。

-  **缓冲代理(Cache Proxy)**：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。

- **智能引用代理(Smart Reference Proxy)**：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。

**1.主要优点**

- 能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。

- 客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性。

**2.主要缺点**

- 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理。

- 实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂，例如远程代理。

**3.适用场景**

- 当客户端对象需要访问远程主机中的对象时可以使用远程代理。
- 当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。
- 当要为一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。
- 当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理。
- 当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。

# 行为型模式

## 职责链模式

职责链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，实现请求发送者和请求处理者解耦。

职责链模式定义如下：

> 职责链模式：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。

![2019061510067_1.png](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/2019061510067_1.png)

在职责链模式结构图中包含如下几个角色：

● **Handler （抽象处理者)** ：它定义了一个处理请求的接口，一般设计为抽象类，其中定义了抽象请求处理方法。

● **ConcreteHandler（具体处理者）**：抽象处理者的子类，实现定义的抽象请求处理方法，具有处理请求和转发请求的功能，处理请求前需判断。

```java
abstract class Handler {
        //维持对下家的引用
    protected Handler successor;
        public void setSuccessor(Handler successor) {
            this.successor=successor;
        }
        public abstract void handleRequest(String request);
    }


class ConcreteHandler extends Handler {
        public void handleRequest(String request) {
            if (请求满足条件) {
                //处理请求
            }
            else {
                this.successor.handleRequest(request);  //转发请求
            }
        }
    }
```

在软件开发中，如果遇到有多个对象可以处理同一请求时可以应用职责链模式，例如在Web应用开发中创建一个**过滤器(Filter)链**来对请求数据进行过滤、工作流系统中实现公文的分级审批等。

**1.主要优点**

- 职责链模式使得对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度。

- 请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接。

- 在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。

- 在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合“开闭原则”的。

**2.主要缺点**

- 由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理。

- 对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而调试不太方便。

- 如果建链不当，可能会造成循环调用，将导致系统陷入死循环。

**3.适用场景**

- 有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的。

- 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。

- 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。

## 命令模式

命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。

命令模式定义如下：

> 命令模式：将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。

![2019061510070_3.png](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/2019061510070_3.png)

在命令模式结构图中包含如下几个角色：

● Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。

● ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。

● Invoker（调用者）：即请求发送者，它通过命令对象来执行请求。

● Receiver（接收者）：接收者执行与请求相关的操作，它具体实现对请求的业务处理。

```java
abstract class Command {
     public abstract void execute();
   }
   
class Invoker {
     private Command command;
       //构造注入
     public Invoker(Command command) {
       this.command = command;
     }
       //设值注入
     public void setCommand(Command command) {
       this.command = command;
     }
     //业务方法，用于调用命令类的execute()方法
     public void call() {
       command.execute();
     }
   }
   
class ConcreteCommand extends Command {
     private Receiver receiver; //维持一个对请求接收者对象的引用
     public void execute() {
       receiver.action(); //调用请求接收者的业务处理方法action()
     }
   }
   
class Receiver {
     public void action() {
       //具体操作
     }
   }
```

有时需多个请求排队，当一个请求发送者发送一个请求时，将不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法，完成对请求的处理。此时，我们可以通过命令队列来实现。

```java
import java.util.*;
    class CommandQueue {
        //定义一个ArrayList来存储命令队列
        private ArrayList<Command> commands = new ArrayList<Command>();
        public void addCommand(Command command) {
            commands.add(command);
        }
        public void removeCommand(Command command) {
            commands.remove(command);
        }
        //循环调用每一个命令对象的execute()方法
        public void execute() {
            for (Object command : commands) {
                ((Command)command).execute();
            }
        }
    }

class Invoker {
        private CommandQueue commandQueue; //维持一个CommandQueue对象的引用
        //构造注入
        public Invoker(CommandQueue commandQueue) {
            this. commandQueue = commandQueue;
        }
        //设值注入
        public void setCommandQueue(CommandQueue commandQueue) {
            this.commandQueue = commandQueue;
        }
        //调用CommandQueue类的execute()方法
        public void call() {
            commandQueue.execute();
        }
    }
```

命令模式将请求发送者与接收者解耦，使得系统具有更好的灵活性和可扩展性。在基于GUI的软件开发，无论是在电脑桌面应用还是在移动应用中，命令模式都得到了广泛的应用。

**1.主要优点**

- **降低系统的耦合度**，请求者与接收者之间实现完全解耦。

- **具有很好的扩展性**。由于增加新的具体命令类不会影响到其他类，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。

- **可以比较容易地设计一个命令队列或宏命令（组合命令）**。

- **为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案**。

**2.主要缺点**

- **使用命令模式可能会导致某些系统有过多的具体命令类**。针对每个对请求接收者的调用操作都需要设计具体命令类。

**3.适用场景**

- 统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。

- 系统需要在不同的时间指定请求、将请求排队和执行请求。

- 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。

- 系统需要将一组操作组合在一起形成宏命令。

## 解释器模式

解释器模式描述了如何为简单的语言定义一个文法，如何在该语言中表示一个句子，以及如何解释这些句子。

解释器模式定义如下：

> 解释器模式：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。解释器模式是一种类行为型模式。 

![20190615100710_1.png](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/20190615100710_1.png)

在解释器模式结构图中包含如下几个角色：

● AbstractExpression（抽象表达式）：在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。

● TerminalExpression（终结符表达式）：终结符表达式是抽象表达式的子类，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。

● NonterminalExpression（非终结符表达式）：非终结符表达式也是抽象表达式的子类，它实现了文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。

● Context（环境类）：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句。

```java
abstract class AbstractExpression {

       public  abstract void interpret(Context ctx);

}

class TerminalExpression extends  AbstractExpression {

       public  void interpret(Context ctx) {

              //终结符表达式的解释操作

       }

}

class NonterminalExpression extends  AbstractExpression {

       private  AbstractExpression left;

       private  AbstractExpression right;


       public  NonterminalExpression(AbstractExpression left,AbstractExpression right) {

              this.left=left;

              this.right=right;

       }


       public void interpret(Context ctx) {

              //递归调用每一个组成部分的interpret()方法

              //在递归调用时指定组成部分的连接方式，即非终结符的功能

       }     

}


class Context {

     private HashMap map = new HashMap();


     public void assign(String key, String value) {

         //往环境类中设值

     }


     public String  lookup(String key) {

         //获取存储在环境类中的值

     }

}
```

解释器模式为自定义语言的设计和实现提供了一种解决方案，它用于定义一组文法规则并通过这组文法规则来解释语言中的句子。

**1. 主要优点**

- 易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。

-  每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。

- 实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。

- 增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”。

**2. 主要缺点**

- 对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。

- 执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。

**3. 适用场景**

- 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。

- 一些重复出现的问题可以用一种简单的语言来进行表达。

- 一个语言的文法较为简单。

## 迭代器模式

将聚合类中负责遍历数据的方法提取出来，封装到专门的类中，实现数据存储和数据遍历分离，无须暴露聚合类的内部属性即可对其进行操作。

迭代器模式定义如下：

> 迭代器模式：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式。

![2019061510084_1.png](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/2019061510084_1.png)

在迭代器模式结构图中包含如下几个角色：

**● Iterator（抽象迭代器）：** 它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法。

**● ConcreteIterator（具体迭代器）：** 它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。

**● Aggregate（抽象聚合类）：** 它用于存储和管理元素对象，声明一个createIterator()方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。

**● ConcreteAggregate（具体聚合类）：** 它实现了在抽象聚合类中声明的createIterator()方法，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator实例。

```java
interface Iterator {
        public void first(); //将游标指向第一个元素
        public void next(); //将游标指向下一个元素
        public boolean hasNext(); //判断是否存在下一个元素
        public Object currentItem(); //获取游标指向的当前元素
    }

class ConcreteIterator implements Iterator {
        private ConcreteAggregate objects; //维持一个对具体聚合对象的引用，以便于访问存储在聚合对象中的数据
        private int cursor; //定义一个游标，用于记录当前访问位置
        public ConcreteIterator(ConcreteAggregate objects) {
            this.objects=objects;
        }
        public void first() {  ......  }
        public void next() {  ......  }
        public boolean hasNext() {  ......  }
        public Object currentItem() {  ......  }
    }

interface Aggregate {
        Iterator createIterator();
    }

class ConcreteAggregate implements Aggregate {
        ......
        public Iterator createIterator() {
        return new ConcreteIterator(this);
        }
        ......
    }
```

通过引入迭代器可以将数据的遍历功能从聚合对象中分离出来，聚合对象只负责存储数据，而遍历数据由迭代器来完成。由于很多编程语言的类库都已经实现了迭代器模式，因此在实际开发中，我们只需要直接使用Java、C#等语言已定义好的迭代器即可，迭代器已经成为我们操作聚合对象的基本工具之一。

**1. 主要优点**

- 它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。

- 迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。

- 在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则”的要求。

**2. 主要缺点**

- 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。

- 抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展，在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是件很容易的事情。

**3. 适用场景**

- 访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据的存储分离，使得访问聚合对象时无须了解其内部实现细节。

- 需要为一个聚合对象提供多种遍历方式。

- 为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口。

## 中介者模式

如果在一个系统中对象之间存在多对多的相互关系，我们可以将对象之间的一些交互行为从各个对象中分离出来，并集中封装在一个中介者对象中，并由该中介者进行统一协调，这样对象之间多对多的复杂关系就转化为相对简单的一对多关系。通过引入中介者来简化对象之间的复杂交互，**中介者模式是“迪米特法则”的一个典型应用**。

中介者模式定义如下：

> 中介者模式：用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。

![20190615100810_3.png](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/20190615100810_3.png)

在中介者模式结构图中包含如下几个角色：

●**Mediator（抽象中介者）：** 它定义一个接口，该接口用于与各同事对象之间进行通信。

●**ConcreteMediator（具体中介者）：** 它是抽象中介者的子类，通过协调各个同事对象来实现协作行为，它维持了对各个同事对象的引用。

●**Colleague（抽象同事类）：** 它定义各个同事类公有的方法，并声明了一些抽象方法来供子类实现，同时它维持了一个对抽象中介者类的引用，其子类可以通过该引用来与中介者通信。

●**ConcreteColleague（具体同事类）：** 它是抽象同事类的子类；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中声明的抽象方法。

中介者模式的核心在于中介者类的引入，在中介者模式中，中介者类承担了两方面的职责：

- **中转作用（结构性）：** 通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，可通过中介者来实现间接调用。

- **协调作用（行为性）：** 中介者可以更进一步的对同事之间的关系进行封装，同事可以一致的和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。

```java
abstract class Mediator {
        protected ArrayList<Colleague> colleagues; //用于存储同事对象
        //注册方法，用于增加同事对象
        public void register(Colleague colleague) {
            colleagues.add(colleague);
        }
        //声明抽象的业务方法
        public abstract void operation();
    }


class ConcreteMediator extends Mediator {
        //实现业务方法，封装同事之间的调用
        public void operation() {
            ......
            ((Colleague)(colleagues.get(0))).method1(); //通过中介者调用同事类的方法
            ......
        }
    }

abstract class Colleague {
        protected Mediator mediator; //维持一个抽象中介者的引用
        public Colleague(Mediator mediator) {
            this.mediator=mediator;
        }
        public abstract void method1(); //声明自身方法，处理自己的行为
        //定义依赖方法，与中介者进行通信
        public void method2() {
            mediator.operation();
        }
    }

class ConcreteColleague extends Colleague {
        public ConcreteColleague(Mediator mediator) {
            super(mediator);
        }
        //实现自身方法
        public void method1() {
            ......
        }
    }
```

在类与类之间存在错综复杂的关联关系的系统中，中介者模式都能得到较好的应用。

**1. 主要优点**

- **简化了对象之间的交互**，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，一对多关系更容易理解、维护和扩展，将原本难以理解的网状结构转换成相对简单的星型结构。

- **可将各同事对象解耦**。中介者有利于各同事之间的松耦合，我们可以独立的改变和复用每一个同事和中介者，增加新的中介者和新的同事类都比较方便，更好地符合“开闭原则”。

- 可以**减少子类生成**，中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使各个同事类可被重用，无须对同事类进行扩展。

**2. 主要缺点**

在具体中介者类中包含了大量同事之间的交互细节，**可能会导致具体中介者类非常复杂**，使得系统难以维护。

**3. 适用场景**

- 系统中**对象之间存在复杂的引用关系**，系统结构混乱且难以理解。

- 一个对象由于引用了其他很多对象并且直接和这些对象通信，导致**难以复用该对象**。

- 想**通过一个中间类来封装多个类中的行为，而又不想生成太多的子类**。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的具体中介者类。

## 备忘录模式

备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，当前很多软件都提供了撤销(Undo)操作，其中就使用了备忘录模式。

备忘录模式定义如下：

> 备忘录模式：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。它是一种对象行为型模式，其别名为Token。

![2019061510095_1.png](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/2019061510095_1.png)

在备忘录模式结构图中包含如下几个角色：

**● Originator（原发器）：** 它是一个普通类，可以创建一个备忘录，并存储它的当前内部状态，也可以使用备忘录来恢复其内部状态，一般将需要保存内部状态的类设计为原发器。

**●Memento（备忘录)：** 存储原发器的内部状态，根据原发器来决定保存哪些内部状态。备忘录的设计一般可以参考原发器的设计，根据实际需要确定备忘录类中的属性。

**●Caretaker（负责人）：** 负责人又称为管理者，它负责保存备忘录，但是不能对备忘录的内容进行操作或检查。在负责人类中可以存储一个或多个备忘录对象，它只负责存储对象，而不能修改对象，也无须知道对象的实现细节。

```java
public class Originator {
        private String state;
        public Originator(){}
    　　// 创建一个备忘录对象
        public Memento createMemento() {
    　　　　return new Memento(this);
        }
    　　// 根据备忘录对象恢复原发器状态
        public void restoreMemento(Memento m) {
    　　　　 state = m.state;
        }
        public void setState(String state) {
            this.state=state;
        }
        public String getState() {
            return this.state;
        }
    }

class Memento {
        private String state;
        public Memento(Originator o) {
    　　　　state = o.getState();
        }
        public void setState(String state) {
            this.state=state;
        }
        public String getState() {
            return this.state;
        }
}

public class Caretaker {
        private Memento memento;
        public Memento getMemento() {
            return memento;
        }
        public void setMemento(Memento memento) {
            this.memento=memento;
}
```

若想实现多次撤销操作，可采用动态数组等集合实现。

**1.主要优点**

- 它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。

- 备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作。

**2.主要缺点**

- 资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免需要占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源。

**3.适用场景**

- 保存一个对象在某一个时刻的全部状态或部分状态，这样以后需要时它能够恢复到先前的状态，实现撤销操作。

- 防止外界对象破坏一个对象历史状态的封装性，避免将对象历史状态的实现细节暴露给外界对象。

## 观察者模式

用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象让其作出反应。其中，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而观察者之间可以没有无关联，可以根据需要增加和删除观察者，使得系统更易于扩展。

观察者模式定义如下：

> 观察者模式：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。

![20190615100100_1.png](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/20190615100100_1.png)

在观察者模式结构图中包含如下几个角色：

● Subject（目标）：目标又称为主题，指被观察的对象。在目标中定义了一个观察者集合，可提供一系列方法来增加和删除观察者对象，定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类。

● ConcreteSubject（具体目标）：具体目标是目标类的子类，当它的状态发生改变时，向它的各个观察者发出通知；实现了在目标类中定义的抽象业务逻辑方法。如果无须扩展目标类，则具体目标类可以省略。

● Observer（观察者）：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者。

● ConcreteObserver（具体观察者）：维护一个指向具体目标对象的引用，存储具体观察者的有关状态，与具体目标的状态保持一致；实现了在抽象观察者中的update()方法。在实现时，可以调用具体目标类的attach()方法将自己添加到目标类的集合中或通过detach()移出。

```java
abstract class Subject {
        //定义一个观察者集合用于存储所有观察者对象
    protected ArrayList observers<Observer> = new ArrayList();
    //注册方法，用于向观察者集合中增加一个观察者
        public void attach(Observer observer) {
        observers.add(observer);
    }
        //注销方法，用于在观察者集合中删除一个观察者
        public void detach(Observer observer) {
        observers.remove(observer);
    }
        //声明抽象通知方法
        public abstract void notify();
    }
}

class ConcreteSubject extends Subject {
        //实现通知方法
        public void notify() {
            //遍历观察者集合，调用每一个观察者的响应方法
            for(Object obs:observers) {
                ((Observer)obs).update();
            }
        }
    }

interface Observer {
        //声明响应方法
        public void update();
    }

class ConcreteObserver implements Observer {
        //实现响应方法
        public void update() {
            //具体响应代码
        }
    }
```

通过使用JDK中的Observer接口和Observable类，可以更加方便地在Java语言中应用观察者模式。在当前流行的MVC架构中也应用了观察者模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。

![20190615100104_1.png](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/20190615100104_1.png)

**1.主要优点**

- 观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。

- 观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。

- 观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。

- 观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。

**2.主要缺点**

- 如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。

- 如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。

- 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

**3.适用场景**

- 一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用。

- 一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁。

- 需要在系统中创建一个触发链，可以使用观察者模式创建一种链式触发机制。

## 状态模式

状态模式**用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题**。当系统中某个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可以使用状态模式。

状态模式定义如下：

> 状态模式：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。

![20190615100106_1.png](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/20190615100106_1.png)

在状态模式结构图中包含如下几个角色：

**● State（抽象状态类）：** 用于定义一个接口封装与环境类的一个特定状态相关的行为，在抽象状态类中声明了各种不同状态对应的方法，而在其子类中实现类这些方法。

**● ConcreteState（具体状态类）：** 它是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。

**● Context（环境类）：** 环境类又称为上下文类，它是拥有多种状态的对象，在环境类中维护一个抽象状态类State的实例，定义当前状态。

```java
// 抽象状态类
abstract class State {
        //声明抽象业务方法，不同的具体状态类可以不同的实现
        public abstract void handle();
    }

// 某个具体状态，可以有多个状态实现类
class ConcreteState extends State {
        public void handle() {
            //方法具体实现代码
        }
    }


// 环境类，用于状态转换及检测等
class Context {
        private State state; //维持一个对抽象状态对象的引用
        private int value; //其他属性值，该属性值的变化可能会导致对象状态发生变化
        //设置状态对象
        public void setState(State state) {
            this.state = state;
        }
        public void request() {
            //其他代码
            state.handle(); //调用状态对象的业务方法
            //其他代码
        }
    }

```

在状态模式的使用过程中，一个对象的状态之间还可以进行相互转换，通常有两种实现状态转换的方式：

- **统一由环境类来负责状态之间的转换**，此时，环境类充当状态管理器角色，提供方法用于实现属性判断和状态转换，如下代码片段所示：

```java
          public void changeState() {
            //判断属性值，根据属性值进行状态转换
          if (value == 0) {
                this.setState(new ConcreteStateA());
            }
            else if (value == 1) {
                this.setState(new ConcreteStateB());
            }
        }
```

- **由具体状态类来负责状态之间的转换**，提供方法来负责属性值的判断和状态转换。此时，状态类与环境类之间就将存在依赖或关联关系，因为状态类需要访问环境类中的属性值，如下代码片段所示：

```java
          public void changeState(Context ctx) {
            //根据环境对象中的属性值进行状态转换
          if (ctx.getValue() == 1) {
                ctx.setState(new ConcreteStateB());
            }
            else if (ctx.getValue() == 2) {
                ctx.setState(new ConcreteStateC());
            }
        }
```

状态模式将一个对象在不同状态下的不同行为封装在一个个状态类中，通过设置不同的状态对象可以让环境对象拥有不同的行为，方便了客户端的使用。

**1. 主要优点**

- **封装了状态的转换规则**，在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中，可以集中管理状态转换代码

- **将所有与某个状态有关的行为放到一个类中**，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为。

- **允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块**。

- 可以**让多个环境对象共享一个状态对象**，从而减少系统中对象的个数。

**2. 主要缺点**

- 状态模式的使用**必然会增加系统中类和对象的个数，导致系统运行开销增大**。

- 状态模式的结构与实现都较为复杂，**如果使用不当将导致程序结构和代码的混乱，增加系统设计的难度**。

- 状态模式**对“开闭原则”的支持并不太好**，增加新的状态类需修改负责状态转换的源代码，且修改某个状态类的行为也需修改对应类的源代码。

**3. 适用场景**

- 对象的行为依赖于它的状态（如某些属性值），状态的改变将导致行为的变化。

- 在代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差。

## 策略模式

**每一个类封装一种具体的算法**称为**策略(Strategy)** ，一般提供一个抽象的策略类来做规则的定义，而每种算法则对应于一个具体策略类。

**策略模式的主要目的是将算法的定义与使用分开，也就是将算法的行为和环境分开**，每一个策略类封装了一种实现算法，使用算法的环境类针对抽象策略类进行编程，符合“依赖倒转原则”。在出现新的算法时，只需要增加一个新的实现了抽象策略类的具体策略类即可。策略模式定义如下：

> 策略模式(Strategy Pattern)：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。策略模式是一种对象行为型模式。

在策略模式结构图中包含如下几个角色：

●**Context（环境类）**：环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。

●**Strategy（抽象策略类）：** 它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。

●**ConcreteStrategy（具体策略类）：** 它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。

```java
abstract class AbstractStrategy {
        public abstract void algorithm(); //声明抽象算法
    }

class ConcreteStrategyA extends AbstractStrategy {
        //算法的具体实现
        public void algorithm() {
           //算法A
        }
    }

class Context {
    private AbstractStrategy strategy; //维持一个对抽象策略类的引用
        public void setStrategy(AbstractStrategy strategy) {
            this.strategy= strategy;
        }
        //调用策略类中的算法
        public void algorithm() {
            strategy.algorithm();
        }
    }

// 客户端

    Context context = new Context();
    AbstractStrategy strategy;
    strategy = new ConcreteStrategyA(); //可在运行时指定类型
    context.setStrategy(strategy);
    context.algorithm();
    
```

在客户端代码中只需注入一个具体策略对象，可以将具体策略类类名存储在配置文件中，通过反射来动态创建具体策略对象，从而灵活地更换具体策略类。**策略模式提供了一种可插入式(Pluggable)算法的实现方案**。

策略模式对应于解决某一问题的一个算法族，允许用户从该算法族中任选一个算法来解决问题，可方便地更换算法或者增加新的算法。只要涉及到算法的封装、复用和切换都可使用策略模式。

**1. 主要优点**

- 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。

- 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族，恰当使用继承可以把公共的代码移到抽象策略类中，从而避免重复的代码。

- 策略模式提供了一种可以替换继承关系的办法。

- 使用策略模式可以避免多重条件选择语句。

- 策略模式提供了一种算法的复用机制，由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类。

**2. 主要缺点**

- 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。

- 策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类。

- 无法同时在客户端使用多个策略类。

**3. 适用场景**

- 一个系统需要动态地在几种算法中选择一种，根据“里氏代换原则”和面向对象的多态性，客户端可以选择使用任何一个具体算法类，并只需要维持一个数据类型是抽象算法类的对象。

- 一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重条件选择语句来实现。此时，使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难以维护的多重条件选择语句。

- 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法与相关的数据结构，可以提高算法的保密性与安全性。

## 模板方法

模板方法模式是一种**基于继承的代码复用技术**，它是一种**类行为型模式**。

模板方法模式定义如下：

> 模板方法模式：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

![20190615100118_2.png](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/20190615100118_2.png)

模板方法模式包含如下两个角色：

- **AbstractClass（抽象类）：** 在抽象类中定义了一系列基本操作，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时，在抽象类中实现了一个模板方法，用于定义一个算法的框架。

- **ConcreteClass（具体子类）：** 它是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作。

基本方法是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：抽象方法、具体方法和钩子方法。

- **抽象方法**：一个抽象方法由抽象类声明、由其具体子类实现。在

- **具体方法**：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。

- **钩子方法**：一个钩子方法由一个抽象类或具体类声明并实现，而其子类可能会加以扩展。通常在父类中给出的实现是一个空实现，并以该空实现作为方法的默认实现，当然钩子方法也可以提供一个非空的默认实现。

```java
abstract class AbstractClass
    {
    //模板方法
    public void TemplateMethod()
    {
            PrimitiveOperation1();
            PrimitiveOperation2();
            PrimitiveOperation3();
    }
    //基本方法—具体方法
    public void PrimitiveOperation1()
    {
        //实现代码
    }
    //基本方法—抽象方法
    public abstract void PrimitiveOperation2();    
    //基本方法—钩子方法
    public virtual void PrimitiveOperation3() {  }
    
}
```

**模板方法模式是基于继承的代码复用技术**，它体现了面向对象的诸多重要思想，是一种使用较为频繁的模式。模板方法模式广泛应用于框架设计中，以确保通过父类来控制处理流程的逻辑顺序，如框架的初始化等。

**1. 主要优点**

- 在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。

- 模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。

- 可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。

- 在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。

**2. 主要缺点**

- 需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象，此时，可结合**桥接模式**来进行设计。

**3. 适用场景**

- 一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。

- 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。

- 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。

## 访问者模式

访问者模式是一种较为复杂的行为型设计模式，它包含访问者和被访问元素两个主要组成部分，这些被访问的元素通常具有不同的类型，且不同的访问者可以对它们进行不同的访问操作。

在使用访问者模式时，被访问元素通常不是单独存在的，它们存储在一个集合中，这个集合被称为“对象结构”，访问者通过遍历对象结构实现对其中存储的元素的逐个操作。

访问者模式定义如下：

> 访问者模式(Visitor Pattern):提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式是一种对象行为型模式。

![20190615200119_1.png](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/20190615200119_1.png)

在访问者模式结构图中包含如下几个角色：

●Vistor（抽象访问者）：抽象访问者为对象结构中每一个具体元素类ConcreteElement声明一个访问操作，从这个操作的名称或参数类型可以清楚知道需要访问的具体元素的类型，具体访问者需要实现这些操作方法，定义对这些元素的访问操作。

●ConcreteVisitor（具体访问者）：具体访问者实现了每个由抽象访问者声明的操作，每一个操作用于访问对象结构中一种类型的元素。

●Element（抽象元素）：抽象元素一般是抽象类或者接口，它定义一个accept()方法，该方法通常以一个抽象访问者作为参数。

●ConcreteElement（具体元素）：具体元素实现了accept()方法，在accept()方法中调用访问者的访问方法以便完成对一个元素的操作。

● ObjectStructure（对象结构）：对象结构是一个元素的集合，它用于存放元素对象，并且提供了遍历其内部元素的方法。它可以结合组合模式来实现，也可以是一个简单的集合对象。

```java
abstract class Visitor
    {
        public abstract void visit(ConcreteElementA elementA);
        public abstract void visit(ConcreteElementB elementB);
        public void visit(ConcreteElementC elementC)
        {
            //元素ConcreteElementC操作代码
        }
    }

class ConcreteVisitor extends Visitor
    {
        public void visit(ConcreteElementA elementA)
        {
            //元素ConcreteElementA操作代码
        }
        public void visit(ConcreteElementB elementB)
        {
            //元素ConcreteElementB操作代码
        }
    }

interface Element
    {
        public void accept(Visitor visitor);
    }


class ConcreteElementA implements Element
    {
        public void accept(Visitor visitor)
        {
            visitor.visit(this);
        }
        public void operationA()
        {
            //业务方法
        }
    }


class ObjectStructure
    {
        private ArrayList<Element> list = new ArrayList<Element>(); //定义一个集合用于存储元素对象
        public void accept(Visitor visitor)
        {
            Iterator i=list.iterator();
            while(i.hasNext())
            {
                ((Element)i.next()).accept(visitor); //遍历访问集合中的每一个元素
            }
        }
        public void addElement(Element element)
        {
            list.add(element);
        }
        public void removeElement(Element element)
        {
            list.remove(element);
        }
    }
```

由于访问者模式的使用条件较为苛刻，本身结构也较为复杂，因此实际应用使用频率不是特别高。当系统中存在一个较为复杂的对象结构，且不同访问者对其所采取的操作也不相同时，可以考虑使用访问者模式进行设计。在XML文档解析、编译器的设计、复杂集合对象的处理等领域访问者模式得到了一定的应用。

**1.主要优点**

- 增加新的访问操作很方便。使用访问者模式，增加新的访问操作就意味着增加一个新的具体访问者类，实现简单，无须修改源代码，符合“开闭原则”。

- 将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中。类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问。

- 让用户能够在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作。

**2.主要缺点**

- 增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”的要求。

- 破坏封装。访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问。

**3.适用场景**

- 一个对象结构包含多个类型的对象，希望对这些对象实施一些依赖其具体类型的操作。在访问者中针对每一种具体的类型都提供了一个访问操作，不同类型的对象可以有不同的访问操作。

- 访问者模式使得我们可以将相关的访问操作集中起来定义在访问者类中，对象结构可以被多个不同的访问者类所使用，将对象本身与对象的访问操作分离。

- 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。
