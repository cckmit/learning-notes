# 发展历史

## 计算机发展的四个阶段

第一阶段：电子管计算机（1946～1957）

第二阶段：晶体管计算机（1957～1964） 

第三阶段：集成电路计算机（1964～1980）

第四阶段：超大规模集成电路计算机（1980～至今）

**电子管计算机：**

1. 集成度小，空间占用大

2. 功耗高，运算速度慢

3. 操作复杂，更换程序需要接线

**晶体管计算机：**

1. 集成度相对较高，空间占用相对较小
2. 功耗相对较低，运行速度较快
3. 操作相对简单，交互更加方便

**集成电路计算机：**

1. 计算机变得更小
2. 功耗更低
3. 计算速度更快

**超大规模集成电路计算机：**

1. 一个芯片集成了上百万的晶体管
2. 速度更快，体积更小，价格更低，更能被大众接受
3. 用途丰富：文本处理，表格处理，高交互游戏与应用

## 微型计算机的发展历史

单核CPU —>>多核CPU

# 分类

1. **超级计算机**
   - 功能最强，运算速度最快，存储容量最大的计算机
   - 多用于国家高科技领域和尖端技术研究
   - 运算速度的单位是TFlop/s（每秒一万亿次浮点计算）

2. **大型计算机**
   - 大型机，大型主机，主机
   - 具有高性能，可处理大量数据与复杂的运算

3. **迷你计算机**
   - 也称为小型机，普通服务器
   - 不需要特殊的空调场所
   - 具备不错的算力，可以完成较复杂的运算

4. **工作站**
   - 高端的通用微型计算机，提供比个人计算机更强大的性能
   - 类似普通台式电脑，体积较大，但性能强劲

5. **微型计算机**
   - 个人计算机，功能齐全
   - 分为台式机，笔记本电脑，一体机

# 体系与结构

**摩尔定律**：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。

## 冯诺依曼体系

冯诺依曼结构的计算机是以运算器为核心的，而现在的计算机则是以存储器为核心的。

**组成**

必须有存储器、控制器、运算器、输入设备、输出设备

**功能**

- 运算器：进行算数逻辑运算
- 存储器：存放数据以及程序

- 控制器：控制程序、数据、运算处理结果
- 输入设备：将指令转换成机器可识别的机器语言

- 输出设备：将指令转换成人可以识别的内容

**结构**

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611416272074-668a1902-aa30-490c-9940-7f18c976f314.webp)

**瓶颈**

CPU和存储器速率之间的问题无法调和，CPU经常空转等待数据的传输，即CPU处理速度快，而存储设备和CPU之间的传输速度慢

## 现代计算机体系

- 现代计算机在冯诺依曼体系结构基础上进行修改
- 解决CPU与存储设备之间的性能差异问题

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611416424008-08c9956e-6b67-46d9-8834-3fea2b538b5e.webp)

- 存储器从广义上理解为可以存储数据的介质：磁带和硬盘等
- 此处所指的存储器是围绕CPU的更高速的设备：内存和CPU的寄存器

# 层次与编程语言

## 程序翻译与程序解析

较为高级的计算机语言L1

较为低级的计算机语言L0

**程序翻译**

L1编写程序，在执行的时候先会生成一个逻辑等价的L0由计算机执行，L0为计算机实际执行的语言，L1生成L0的过程被成为程序翻译，生成的东西被称为编译器，整个过程是程序翻译的过程。

**程序解析**

使用L1进行逻辑描述，为了执行L1，还要使用L0语言实现另外一个程序，它将L1作为输入进行执行，每一个L1语句都会在L0里进行等价的逻辑转换，这个过程被称为程序解析，使用L0语言生成的另外一个程序被称为解释器。

**区别：**

1. 计算机执行的指令都是L0
2. 翻译过程生成新的L0程序，解析过程不生成新的L0
3. 解析的过程由L0编写的解释器去解析L1程序

翻译型语言：C/C++，Object-C，Golang

解析型语言：Python，PHP，JavaScript

翻译+解释型语言：Java，C#

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611416424365-528529c3-1020-4287-a4ce-f88c40139291.webp)

## 计算机的层次与编程语言

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415510238-67c3f561-9000-4294-8fb9-8138e8cfc17c.webp)

### 硬件逻辑层

- 门、触发器等逻辑电路组成
- 属于电子工程的领域

### 微程序机器层

- 编程语言是微指令集
- 微指令所组成的微程序直接交由硬件执行

### 传统机器层

- 编程语言是CPU指令集（机器指令），
- 编程语言和硬件是直接相关

- 不同架构的CPU使用不同的CPU指令集

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415510244-886086c9-c549-46ca-a350-fbbce201ab9b.webp)

### 操作系统层

- 向上提供了简易的操作界面
- 向下对接了指令系统，管理硬件资源

- 操作系统层是在软件和硬件之间的适配层

### 汇编语言层

- 编程语言是汇编语言
- 汇编语言可以翻译成可直接执行的机器语言

- 完成翻译的过程的程序就是汇编器

### 高级语言层

- 编程语言为广大程序员所接受的高级语言
- 高级语言的类别非常多，有几百种

- 常见的高级语言有：Python、Java、C/C++、Golang等

### 应用层

- 满足计算机针对某种用途而专门设计的应用

# 计算单位

## 容量单位

- 物理层面，高低电平记录信息
- 高电平表示1，低电平表示0，理论上只认识0/1两种状态，0、1称为bit
- 0/1表示的内容太少，需更大的容量表示方法，催生了其他单位

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415510618-701a6618-9414-42c4-b382-aead83263111.webp)

## 速度单位

**网络速度**

网络中常用单位为（Mbps），所以在进行运算的时候要除以8得到实际的网络速度

1M/s=1Mbps=1Mbit/s 

100M/s=100Mbps=100Mbit/s 

100Mbit/s=(100/8)MB/s=12.5M/s 

**CPU速度** 

- CPU的速度一般体现为CPU的时钟频率，单位一般用赫兹（Hz）表示，目前主流的CPU时钟频率都在2GHz以上
- Hz是指秒分之一，是指每秒钟周期性变动重复次数的计量，并不是描述计算机领域所专有的单位，但并不妨碍描述CPU的速度
- 对于CPU的频率实际上是指每秒钟高低电平变换的次数，2GHz=2*1000^3Hz=每秒20亿次

# 字符和编码集

## 字符编码集的历史

### ASCII码

- 使用7个bits就可以完全表示ASCII码
- 包含95个可打印字符

- 33个不可打印字符（包括控制字符）![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415510277-0868d354-0e9d-4164-a763-6e5a062cdb43.webp)

### Extended ASCII码

- 由于很多应用或者国家中的符号都无法表示，则第一次对ASCII码进行扩充：7bits=>8bits![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415510781-053e2117-a792-4962-a622-ff6051ba5f49.webp)

### 字符编码集的国际化

- 欧洲、中亚、东亚、拉丁美洲国家的语言多样性
- 语言体系不一样，不以有限字符组合的语言

- 中国、韩国、日本等的语言最为复杂

## 中文编码集

### GB2312

- 《信息交换用汉字编码字符集---基本集》
- 一共收录了7445个字符
- 包括6763个汉字和682个其他符号

### GBK

- 《汉字内码扩展规范》
- 向下兼容GB2312，向上支持国际ISO标准
- 收录了21003个汉字，同时支持全部中日韩汉字

### Unicode：兼容全球的字符集

- Unicode：统一码、万国码、单一码
- Unicode定义了世界通用的符号集，UTF-*实现了编码

- UTF-8以字节为单位对Unicode进行编码
- 编程推荐使用UTF-8编码

# 总线

## 总线的概述

总线是计算机中各个部件的信息传输线。

### 总线的传输方式

- **并行方式**：同一时间内，传输多位数据，而计算机的位数，就是按照系统总线传输的数据位数划分的。

- **串行方式**：同一时间内，由一条总线串行传输数据。

- **面向CPU双总线结构**：在这种结构中，包括了M总线（CPU与主存之间的数据传输总线）、I/O总线。

  - **优点：多条总线，并行传输，效率高。**
  - **缺点：IO容易被占用打断，并且占用了CPU**

  <img src="https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611416929172-370d2433-cc31-4646-94ef-b59b772015bf.webp" alt="img" style="zoom: 50%;" />

- **单总线结构**：只有一条系统总线。计算机中的所有设备都连接在这条总线上。

  - **缺点：总线容易冲突，且占用CPU**

  ![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611416929157-c2743747-891f-42a6-a2ae-24c8c2924e95.webp)

- **以存储器为中心的双总线结构**：在CPU和主存之间加入了一条存储总线。

  - **优点：不占用CPU且其需要的数据既可从主存中获取，又可以从总线中获取；系统总线和存储总线交互，提高了效率的同时，还减轻了系统总线的负担。**

  ![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611416929130-a603273d-887b-4fba-a11a-bd464421b248.webp)

### 总线的例子

- USB:通用串行总线(Universal Serial Bus)

  - 提供了对外连接的接口

  - 不同设备可以通过USB接口进行连接
  - 连接的标准，促使外围设备接口的统一

- PCI总线：外置显卡插在此处

- ISA总线

- ThunderBolt总线（苹果电脑的总线）

## 总线的分类

### 片内总线

- 芯片内部的总线
- 可连接寄存器与寄存器、寄存器与控制器、运算器等

- 高集成度芯片内部的信息传输线，大大简化芯片内的电路结构

### 系统总线

- 连接计算机各种设备的总线

#### 数据总线

- 双向传输各个部件的数据信息
- 数据总线的位数（总线宽度）是数据总线的重要参数，一般与CPU位数相同

#### 地址总线

- 指定源数据或目的数据在内存中的地址，如果地址总线位数=n，则寻址范围为0~2^n
- 地址总线的位数与存储单元有关

#### 控制总线

- 控制总线是用来发出各种控制信号的传输线
- 控制信号经由控制总线从一个组件发给另外一个组件

- 控制总线可以监视不同组件之间的状态（就绪/未就绪）

## 总线性能标准

- 总线宽度：数据总线的根数
- 总线带宽：总线的数据传输速率，也就是每秒传输的最大字节数，单位MBp/S

- 总线复用：一条信号线上分时传送两种信号
- 信号线数：地址总线、数据总线 、控制总线的数目总和

- 总线结构：单总线结构、多总线结构、双总线结构等

## 总线的仲裁

### 为什么需要总线的仲裁？

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611414499187-9f7bb3b6-a4f9-4553-af21-ae24c8a6edbf.webp)

- 假设主存需要和硬盘、I/O设备交换数据，硬盘和I/O设备均已准备就绪，总线应该由哪个使用，需要仲裁器解决这个矛盾问题，否则会引起设备之间的冲突
- 仲裁器是为了解决总线使用权的冲突问题

### 总线的仲裁方法

#### 链式查询

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611414499154-2f56761e-3e0f-4d6b-a6d8-ed5458978908.webp)

- 假设设备2需要使用总线，设备2通过仲裁控制线向仲裁控制器发送总线使用的请求
- 仲裁控制器接收到请求后，发出允许使用的信号

- 信号会通过链式优先进入设备1，如果设备1不需要使用的话，会进入设备2，设备2拿到信号后就可以使用总线
- 如果设备1和设备2均发送使用请求，则会按照链式顺序依次使用总线

#### 链式查询的优缺点

- 好处：电路复杂度低，仲裁方式简单

- 坏处：

  - 优先级低的设备难以获得总线的使用权

  - 对电路的故障敏感

#### 计时器定时查询

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611414499104-fe5871ac-c4ba-45ff-a1ea-fa9362a88b41.webp)

- 仲裁控制器对设备编号并使用计数器累计计数
- 接收到仲裁信号后，往所有设备发出当前计数值

- 计数值与设备编号一致则获得总线使用权

#### 独立请求

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611414499492-548bdd85-efb8-4890-98a5-9828d261301d.webp)

- 每个设备均有总线独立连接仲裁器
- 设备可单独向仲裁器发送请求和接收请求

- 当同时收到多个请求信号，仲裁器有权按照优先级分配使用权

#### 独立请求的优缺点

- 好处：响应速度快，优先顺序可动态改变
- 坏处：设备连线多，总线控制复杂

## 总线通信方式

### 同步通信

**同步通信：由统一时标控制通信的数据传输**。

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611416929238-8d892bbd-059d-4bb1-93ba-977f027c22c5.webp)

- 这张图片表示的是某个设备向CPU传输数据的过程。 整个的传输过程如下：

  - 在T1时间的上升沿（上升沿这个词其实不难理解，就是时钟向上走的部分，对应下降沿就是时钟线向下走的过程），主设备（CPU）给出读数据的目的地址

  - 在T2上升沿，主设备（CPU）给出读命令

  - 在T3上升沿，从设备给出数据信息，执行读数据操作

  - T3下降沿，读命令、数据信号撤销

  - T4，地址线撤销

### 异步通信

没有统一的时标，只需要主设备发出请求，从设备发出响应即可。

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611416929175-828b0fcc-634e-4dcd-8647-65c2bf7a2514.webp)

### 半同步通信

结合了同步和异步通信。

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611416929236-299db61d-639b-4967-9979-fe9cafe8891a.webp)

# I/O 设备

## 常见的输入输出设备

### 字符输入设备：键盘

- 薄膜键盘
- 机械键盘

### 图形输入设备

- 鼠标
- 数位板：输入板和压感笔，常用于绘图设计创作

- 扫描仪：将图形信息转换为数字信号

### 图像输出设备

- 显示器
- 打印机

- 投影仪

## 输入输出接口的通用设计

1. **设计输入输出接口的需求**

2. 支持读取数据
3. 允许向设备发送数据
4. 接口需要判断设备是否被占用
5. 判断设备是否已经连接
6. 判断设备是否正常启动

### 数据线

- 是I/O设备与主机之间进行数据交换的传送线
- 单向传输数据线

- 双向传输数据线

### 状态线

- I/O设备状态向主机报告的信号线
- 查询设备是否已经正常连接并就绪

- 查询设备是否已经被占用

### 命令线

- CPU向设备发送命令的信号线
- 发送读写信号

- 发送启动停止信号

### 设备选择线

- 主机选择I/O设备进行操作的信号线
- 对连在总线上的设备进行选择

## CPU与I/O设备的通信

CPU速度与I/O 设备不一致

### 程序查询方式

利用CPU向I/O设备发送读取指令，然后再检查I/O设备的状态，如果I/O设备已准备，则一个一个字节的将数据传输到CPU中；若未准备，则CPU将会不断的向I/O设备发送查询请求，直到I/O设备准备好了。 

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611475113361-890f59c2-3e56-4175-8858-153aee8d419e.webp)

### 程序中断方式

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611475113369-005bc08a-b515-45fa-82c2-cbe1d552ddfa.webp)

- 当外围I/O设备就绪时，向CPU发出中断信号
- CPU有专门的电路响应中断信号，响应中断不会立即执行，有一定的响应时间

- 程序中断提供低速设备通知CPU的一种异步方式
- CPU可以高速运转同时兼顾低速设备的响应，如果频繁打断CPU，会降低CPU使用效率

### DMA(直接存储器访问)

硬盘、外置显卡都有DMA设备。

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611414499175-bb463028-f229-45c8-85e5-150c606ea524.webp)

- DMA直接连接主存与I/O设备
- DMA工作时不需要CPU参与，大大提升CPU的效率

**传送数据方式**

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611475113375-6b4dfbad-aa26-4a21-87fe-f2e7dd351da7.webp)

# 存储器

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611461049919-b96ac608-f512-4035-9e2e-bf787ea1fb55.webp)

## 存储器的基本结构

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611416424012-babc029d-904d-4705-b314-1fc96bbdf714.webp)

- 存储体：存储的部件即可，可以存放数据。 
- MAR：存储器地址寄存器；
- MDR：存储器数据寄存器。

## 存储器的分类

### 按存储介质分类

- 半导体存储器

  - 内存

  - U盘

  - 固态硬盘

- 磁存储器

  - 磁带

  - 磁盘

### 按存取方式分类

- 随机存储器（RAM）

  - 随机读取

  - 与位置无关

- 串行存储器

  - 与位置有关

  - 按顺序查找

- 只读存储器（ROM）

  - 只读不写

## 存储器的层次结构

- 存储器要考虑的三个因素：**读写速度、存储容量、价格**

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611414499338-fc221959-d550-4451-b317-82492863d10b.webp)

### 缓存-主存层次

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611414499330-9dff42f2-92db-40de-b435-effd382551f6.webp)

- 原理：局部性原理
- 实现：在CPU与主存之间增加一层速度快（容量小）的Cache
- 目的：解决主存速度不足的问题

**局部性原理**

局部性原理是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中

### 主存-辅存层次

- 原理：局部性原理
- 实现：主存之外增加辅助存储器（磁盘、SD卡、U盘等）

- 目的：解决主存容量不足的问题

## 主存储器与辅助存储器

### 主存储器--内存

- RAM(随机存取存储器：Random Access Memory)
- RAM通过电容存储数据，必须隔一段时间刷新一次

- 如果断电，那么一段时间后将丢失所有数据

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611414499527-3686e7d5-0dd2-464d-a22e-c60529f02367.webp)

- 32位系统：最多只能支持4 GB内存，因为地址总线只有32位，即$$2^{32} $$= 4 x 2$$^{30}$$ = 4 GB
- 64位系统：最多能支持$$2^{32}$$内，即$$2^{64}$$ = $$2^{34}$$ x $$2^{30}$$ = $$2^{34}$$GB

### 辅助存储器--磁盘

#### 磁盘的物理结构

- 表面是可磁化的硬磁特性材料
- 移动磁头径向运动读取磁道信息

#### 磁盘的调度算法

- 先来先服务算法：按顺序访问进程的磁道读写需求

- 最短寻道时间算法

  - 与磁头当前的位置有关

  - 优先访问离磁头最近的磁道

- 扫描算法（电梯算法）

  - 每次只往一个方向运动

  - 到达一个方向需要服务的尽头再反方向移动

- 循环扫描算法

  - 在扫描算法的基础上，只往一个方向读取，由内到外或由外到内

## 高速缓存

高速缓存位于缓存-主存层次，在CPU与主存中间，目的是为了解决CPU与主存速度不匹配的问题。

**主存的存储结构**

- 字：是指存放在一个存储单元中的二进制代码组合
- 字块：存储在连续的存储单元中被看做是一个单元的一组字

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611414499243-1025ab3d-2927-4e50-835a-9f6a2a703a72.webp)

#### 高速缓存的存储结构

- 缓存和主存存储的逻辑结构类似
- 缓存的容量较小

- 缓存的速度更快

#### 缓存映射方式

字段含义：

- 标记：表明该缓存是否有效，0为没命中，需由主存推送给Cache，为1则命中，将Cache推送给缓存

**直接映射**：**主存中的每一组字块对应着Cache中的相应字块。**

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611461049936-724fce09-307b-4a59-bbc4-bd1fe8c75846.webp)

**全相联映射：主存中的字块可以对应任何一个Cache中的字块；缓存失效的时候则挑一个失效的Cache块替换。**

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611461050043-3ff1301e-4d4b-414d-9f2e-d427f528f0d6.webp)

**组相联映射：主存中的每一组字块中的每一个字块对应着Cache中的一个相应字块，但Cache中的字块分成了两组，这种方式也叫做二路组相联。**

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611461049968-615b8a2d-079d-49db-a388-10fb088e22b0.webp)

#### 缓存的性能指标

- 命中率![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611414499348-df3d8aca-ba64-4919-96c1-a9097dcfa63b.webp)
- 访问效率![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611414499594-d63998a2-f40a-4040-b5a1-a6d3b18b9783.webp)

#### 高速缓存的替换策略

高速缓存的替换时机，缓存中没有数据，需要从主存载入所需数据

- 随机算法

- 先进先出算法（FIFO）

  - 把高速缓存看做是一个先进先出的队列，优先替换最先进入队列的字块

- 最不经常使用算法（LFU）

  - 优先淘汰最不经常使用的字块

  - 需要额外的空间记录字块的使用频率

- 最近最少使用算法（LRU）

  - 优先淘汰一段时间内没有使用的字块

  - 有多种实现方法，一般使用双向链表

  - 把当前访问节点置于链表前面（保证链表头结点是最近使用的）

  - 淘汰时淘汰链表尾部节点

# 控制器

控制器是协调和控制计算机运行的。

**组成**

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611416424041-202b2200-0d60-481f-a0f8-a9f12ea057de.webp)

## 程序计数器（PC）

- 程序计数器用来存储下一条指令的地址
- CPU会循环从程序计数器中拿出指令

- 当指令被拿出时，指向下一条指令

## CU控制单元

- 存放了操作码，指令寄存器会对CU控制单元发出请求，得到具体的操作。

## 指令译码器（IR）

- 指令译码器是控制器的主要部件之一
- 计算机指令由操作码和地址码组成
- 翻译操作码对应的操作以及控制传输地址码对应的数据

## 各种寄存器

### 指令寄存器

- 指令寄存器是控制器的主要部件之一
- 缓存从主存或高速缓存取的计算机指令

### 主存地址寄存器

- 保存当前CPU正要访问的内存单元的地址

### 主存数据寄存器

- 保存当前CPU正要读或写的主存数据

## 通用寄存器

- 用于暂时存放或传送数据或指令
- 可保存ALU(算术逻辑单元)的运算中间结果

- 容量比一般专用寄存器要大

# 运算器

**组成**

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611416424244-207ca8e1-d1b7-4eca-a7ce-032a10456bff.webp)

## 数据缓冲器

- 分为输入缓冲和输出缓冲
- 输入缓冲暂时存放外设送过来的数据

- 输出缓冲暂时存放送往外设的数据

## ALU

- ALU:算术逻辑单元，是运算器的主要组成
- 常见的位运算（左右移，与或非等）

- 算术运算（加减乘除等）

## 状态字寄存器

- 存放运算状态（条件码、进位、溢出、结果正负等）
- 存放运算控制信息（调试跟踪标记为、允许中断位等）

## 通用寄存器

- 用于暂时存放或传送数据或指令
- 可保存ALU(算术逻辑单元)的运算中间结果
- 容量比一般专用寄存器要大

# 指令系统

## 机器指令的形式

- 机器指令主要由两部分组成：操作码字段、地址码字段

### 操作码字段

- 操作码指明指令所要完成的操作
- 操作码的位数反映了机器的操作种类，比如操作码有8位，则最多就有2^8 = 256种操作

### 地址码字段

- 地址码直接给出操作数或者操作数的地址

- 分三地址指令、二地址指令和一地址指令

  - 三地址指令![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611414499215-aabc8350-d9e0-4392-854b-2877d3c70f43.webp)

  - 二地址指令![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611414499398-ce4d69b4-bb4b-4fd0-ae44-29c1a187afe3.webp)

  - 一地址指令![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611414499417-58547b60-9fda-4baa-9a2c-882821ab7295.webp)

  - 零地址指令，在机器指令中无地址码，即空操作、停机操作、中断返回操作等

## 机器指令的操作类型

### 数据传输

- 寄存器之间、寄存器与存储单元、存储单元之间传送（存储单元可以是主存，高速缓存或者辅存）
- 数据读写、交换地址数据、清零置一等操作

### 算术逻辑操作

- 操作数之间的加减乘除运算
- 操作数的与或非等逻辑位运算

### 移位操作

- 数据左移（乘2）、数据右移（除2）
- 完成数据在算术逻辑单元的必要操作

### 控制指令

- 等待指令、停机指令、空操作指令、中断指令等

## 机器指令的寻址方式

### 指令寻址

- 顺序寻址
- 跳跃寻址

### 数据寻址

- 立即寻址：指令直接获得操作数，无需访问存储器
- 直接寻址：直接给出操作数在主存的地址，寻找操作数简单，无需计算数据地址

- 间接寻址：指令地址码给出的是操作数地址的地址，需要访问一次或多次主存来获取操作数

#### 三种数据寻址的优缺点

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611414499913-a900777e-b9b6-4648-9291-7db132fe7cc7.webp)

# 指令的执行过程

以取数指令为例子。

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611416424007-aeeaa937-3650-4cb5-9533-d10350ea1815.webp)

- PC程序计数器+1，开始指向下一个地址。
- 存储器地址寄存器（MAR）中存放着下一个地址，根据这个地址指向存储体中的指令数据。

- 从存储体得到数据，存入数据寄存器（MDR）
- 得到指令，格式为指令码+操作码（当前操作就是：取数操作-地址），指令写入IR指令寄存器中。

- 指令寄存器询问CU控制单元当前是何种操作，得到取指令操作的回复
- 指令中的数据地址存入地址寄存器（MAR）

- 通过地址寄存器(MAR)得到存储体中当前地址存储的数据
- 得到的数据存入数据寄存器中(MDR)

- 数据寄存器中的数据写入ACC，完成整个操作
- PC程序计数器+1，开始新一轮的判断

# 进制运算的基础

## 进制概述

- 进位制是一种记数方式，亦称进位记数法或者位值计数法
- 有限种数字符号来表示无限的数值

- 使用的数字符号的数目称为这种进位制的基数或底数

## 二进制运算的基础

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1640846062363-f75167da-49e2-4537-bb75-29317ce714c1.png)

**（整数）二进制转十进制：按权展开法**

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415755733-f126497b-0258-4bea-be09-fa0a478d106f.webp)

**（整数）十进制转换成二进制：重复相除法**

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415755862-cb36a22a-e6bd-4a8c-9d58-6759a29ee8c6.webp)

**（小数）二进制转换成十进制：按权展开法**

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415755681-a74e401d-f4c7-40c1-b6cc-842a94c69ce0.webp)

**（小数）十进制转换成二进制：重复相乘法**

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415756090-3ec1845f-0148-4b4c-baa7-82185d6c2ba8.webp)

## 补码、原码、反码

**原码表示法**

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415755695-c659e1b3-0778-4278-893a-aa7a1957cfa8.webp)

- 使用0表示正数，使用1表示负数
- 规定符号位位于数值第一位

- 表达简单明了，是人类最容易理解的表示法

**原码表示法的缺点**

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415755639-2d5e1c64-cdae-453b-8622-39e4693de3a5.webp)

**二进制的补码表示法**

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415755842-d51c2c0a-a78e-44ba-9ecf-739b12ac599d.webp)

**例子**

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415755948-9df68a72-a457-4361-a28b-88c2528e0f6b.webp)

**引进补码的目的**

- 减法运算复杂，希望找到使用正数替代负数的方法
- 使用加法替代减法操作，从而消除减法

- 但是计算补码的过程中，还是使用了减法

**二进制的反码表示法**

- 反码的目的是找出原码和补码之间的规律，消除转换过程中的减法

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415755950-44f20193-3581-4d76-85cc-c1ff8e11e56b.webp)

**原码、补码、反码规律**

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415756072-71f7107c-3250-49d8-97ae-fe7ab435c8a8.webp)

# 定点数与浮点数

## 定点数的表示方法

- 小数点固定在某个位置的数称之为定点数

**纯小数和纯整数**

- 如果数字不是纯小数，也不是纯整数，则需要乘以比例因子以满足定点数保存格式![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415755681-babcc386-cbed-4582-82c8-3d2445750916.webp)

## 浮点数的表示方法

- 计算机处理的很大程度上不是纯小数或纯整数
- 数据范围很大，定点数难以表达且定点数不够灵活

### 浮点数的表示格式

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415756207-e8989e16-ae11-4c72-ad2e-9adca63a4edb.webp)

- S：尾数（尾数必须使用纯小数）
- r：基数

- j：阶码（阶码为二进制）

### 浮点数的表示范围

- 假设阶码数值取m位，尾数数值取n位
- 上溢：这个数绝对值太大了。浮点数无法表示

- 下溢：这个数绝对值太小了。浮点数无法表示
- 单精度浮点数：使用4字节、32位来表达浮点数（float）

- 双精度浮点数：使用8字节、64位来表达浮点数（double）![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415756032-58d11f0c-8c88-4858-a9fc-a723a55609b6.webp)

### 浮点数的规格化

- 尾数规定使用纯小数
- 尾数最高位必须是1

## 定点数与浮点数的对比

- 当定点数与浮点数位数相同时，浮点数表示的范围更大
- 当浮点数尾数为规格化数时，浮点数的精度更高

- 浮点数的运算包含阶码和尾数，浮点数的运算更为复杂
- 浮点数在数的表示范围、精度、溢出处理、编程等方面均优于定点数

- 定点数在数的运算规则、运算速度、硬件成本方面优于浮点数

## 定点数的加减法运算

### 加法操作

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415755710-11c8f27d-587a-45eb-8743-d311f38f6c07.webp)

#### 例子

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415756046-2194909e-4bb0-4270-aeda-2ba515f5fd26.webp)

#### 判断溢出

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415755716-3861c818-c6c5-44cd-b072-d2f6a671e159.webp)

- 双符号位判断法

  - 单符号位表示变成双符号：0=>00, 1=>11

  - 双符号位产生的进位丢弃

  - 结果的双符号位不同则表示溢出![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415755968-d6495908-ddd4-4e5e-8d64-88300c1ec418.webp)

### 减法操作

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415756093-3992f661-5d80-460d-94b0-a0db724e2e2c.webp)

## 浮点数的加减法运算

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415755733-1208517e-10d9-4b79-9b23-6061adc7296f.webp)

### 对阶

- 对阶的目的是使得两个浮点数阶码一致，使得尾数可以进行运算
- 浮点数尾数运算简单

- 浮点数尾数实际小数位与阶码有关
- 阶码按小阶看齐大阶的原则

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415755808-53945628-adca-4324-9fff-a25428da6940.webp)

### 尾数求和（与定点数相同）

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415755922-22be7e32-6c21-4ec2-9846-4f6e09788481.webp)

### 尾数规格化

- 对补码进行规格化需要判断两种情况：S>0和S<0![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415755748-e42e8b40-59c8-420f-a9c8-a9bf01ac50ad.webp)

#### 左移规格化

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415756409-1d522561-2fc8-4805-b2ca-3debe76b806b.webp)

#### 右移规格化

- 双符号位不一致下需要右移
- 右移的话则需要进行舍入操作

- 舍去1则需要加1，舍去的是0则不进行加1操作
- 定点运算双符号不一致为溢出，浮点运算尾数双符号位不一致不算溢出，因为可以进行右移规避

- 浮点运算主要通过阶码的双符号位判断是否溢出，如果规格化后，阶码双符号位不一致，则认为是溢出

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415756491-6385164b-205e-49da-a28d-74064af06721.webp)

## 浮点数的乘除法运算

### 运算过程

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415755742-ae0f9594-1ee5-4507-bcdc-74c92f257068.webp)

### 浮点数的乘法

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415756013-051ad908-9530-4707-b8cf-108b80174168.webp)

### 浮点数的除法

![img](https://isbut-blog.oss-cn-shenzhen.aliyuncs.com/markdown-img/1611415755962-32ee11b3-da3a-4359-ae0d-6d12315b177a.webp)